=~=~=~=~=~=~=~=~=~=~=~= PuTTY log 2021.10.04 18:03:21 =~=~=~=~=~=~=~=~=~=~=~=
login as: studn ent
student@localhost's password: 
Welcome to Ubuntu 16.04.6 LTS (GNU/Linux 4.4.0-210-generic i686)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

66 packages can be updated.
2 updates are security updates.

New release '18.04.6 LTS' available.
Run 'do-release-upgrade' to upgrade to it.


Last login: Mon Oct  4 17:58:11 2021 from 10.0.2.2
student@2ac:~$ tar xvfxz examen1.tar.gz
program.c
results.xls
student@2ac:~$ ls
2ac-pl4-uo281827  examen1.tar.gz  program.c  results.xls
student@2ac:~$ less /proc/cpuingofo > examen1/cpu.txt
-bash: examen1/cpu.txt: No such file or directory
student@2ac:~$ sudo less /prsudo less proc/ /proc /cpuinfor  > examen1./cpu.txt
-bash: examen1/cpu.txt: No such file or directory
student@2ac:~$ ls
2ac-pl4-uo281827  examen1.tar.gz  program.c  results.xls
student@2ac:~$ lssudo less /proc/cpuinfo > examen1/cpu.txtcpu.txtcpu.txtcpu.txtcpu.txtcpu.txtcpu.txtcpu.txtcpu.txtcpu.txt cpu.txt
[sudo] password for student: 
student@2ac:~$ ls
2ac-pl4-uo281827  cpu.txt  examen1.tar.gz  program.c  results.xls
student@2ac:~$ usudo nano -c progaram.c
[ Reading File ][ Read 283 lines ]  GNU nano 2.5.3              File: program.c                                   #include <stdio.h>#include <stdlib.h> #include <math.h>#include <pthread.h>#define MAX_NTASKS_NTHREADS 22 // Maximum number of tasks and threads///////////////////////////////////////////////////////////////////////////////$// Start measuring time// TODO: Write down your DNI without the final letter///////////////////////////////////////////////////////////////////////////////$const unsigned int DNI = *** GAP 1 ***; // Example: const unsigned int DNI = 12$const unsigned long NELEMENTS = 55440; // Number of elements to be processed by$// Structure with the parameters of each threadtypedef struct{double *data; // Array with data^G Get Help  ^O Write Out ^W Where Is  ^K Cut Text  ^J Justify   ^C Cur Pos^X Exit^R Read File ^\ Replace   ^U Uncut Text^T To Spell  ^_ Go To Line  GNU nano 2.5.3              File: program.c                                   #include <stdio.h>#include <stdlib.h> #include <math.h>#include <pthread.h>#define MAX_NTASKS_NTHREADS 22 // Maximum number of tasks and threads///////////////////////////////////////////////////////////////////////////////$// Start measuring time// TODO: Write down your DNI without the final letter///////////////////////////////////////////////////////////////////////////////$const unsigned int DNI = *** GAP 1 ***; // Example: const unsigned int DNI = 12$const unsigned long NELEMENTS = 55440; // Number of elements to be processed by$// Structure with the parameters of each threadtypedef struct{double *data; // Array with data[ Read 283 lines ]^G Get Help  ^O Write Out ^W Where Is  ^K Cut Text  ^J Justify   ^C Cur Pos^X Exit^R Read File ^\ Replace   ^U Uncut Text^T To Spell  ^_ Go To Line  GNU nano 2.5.3              File: program.c                                   #include <stdio.h>#include <stdlib.h> #include <math.h>#include <pthread.h>#define MAX_NTASKS_NTHREADS 22 // Maximum number of tasks and threads///////////////////////////////////////////////////////////////////////////////$// Start measuring time// TODO: Write down your DNI without the final letter///////////////////////////////////////////////////////////////////////////////$const unsigned int DNI = *** GAP 1 ***; // Example: const unsigned int DNI = 12$const unsigned long NELEMENTS = 55440; // Number of elements to be processed by$// Structure with the parameters of each threadtypedef struct{double *data; // Array with data[ Read 283 lines ]^G Get Help  ^O Write Out ^W Where Is  ^K Cut Text  ^J Justify   ^C Cur Pos^X Exit^R Read File ^\ Replace   ^U Uncut Text^T To Spell  ^_ Go To Line                    File: program.c                                                             //////345678  a taskunsigned int minIndex; // Minimum array index to process unsigned int maxIndex; // Maximum array index to process} threadArgs_t;// Data to be proceeeed by the tasks. One pointer per taskdouble *data[MAX_NTASKS_NTHREADS] ;// Thread function argumentsthreadArgs_t threadArgs[MAX_NTASKS_NTHREADS]; int task(unsigned int taskIndex, unsigned int nTaskThreads, pthread_t threadIDs[]);double mcos(double val);double msin(double val);double mcosh(double val);double msinh(double val);double mexp(double val);double mlog(double val);double msqrt(double val);double mfabs(double val);double mfloor(double val);double mceil(double val);[ line 1/284 (0%), col 1/19 (5%), char 0/7768 (0%) ]^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     ^Y Prev Page   M-\ First Line M-W WhereIs Next^X Exit^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  ^V Next Page   M-/ Last Line  M-] To Bracket221 (419/7768 (0%) ]3118 (540421 (458[ line 5/284 (1%), col 1/1 (100791 [ line 6/284 (2%), col 1/70 (180[ line 7/284 (2%), col 1/1 (100150/7768 (1%) ]883 (1%), char 1519324 (4234310/284 (3%), col 1/54 (1%), char 258/7768 (3%) ]1833124[ line 10/284 (3%), col 54/54 (100%), char 311/7768 (4%) ] [ line 11/284 (3%), col 54/83 (6565247 (6244853072/87 (596185074496385274162051394083/87 (4972861750543943832943Modified8/862/77677/85 (431/77666/84 (420/77655/8329/77644/82 (418/77633/81 (407/77622/806/7761G1/79 (395/77600/78 (384/775929/77 (373/77588/76 (362/77577/751/77566/74 (350/7755double mfloor(double val);double mceil(double val);// Functions to run on each elementconst unsigned int NFUNCTIONS = 10;double (*funcArray[10])(double) = {mcos, msin, mcosh, msinh, mexp, mlog, msqrt, mfabs, mfloor, mceil}; unsigned long NTIMES[10] = {40, 20, 10, 9, 6, 5, 4, 3, 2, 1};int main(int argc, char* argv[])struct timespec t1, t2;double time12;// Get program argumentsif (argc != 3){fprintf(stderr, "Usage: %s ntasks nthreads\n", argv[0]);exit(EXIT_FAILURE);}nTasks = atoi(argv[1]);nThreads = atoi(argv[2]); if ((nTasks <= 0) || (nTasks > MAX_NTASKS_NTHREADS)){ fprintf(stderr, "ERROR: task count should be between [1, %d]\n", MAX_NTASKS_NTHREADS); exit(EXIT_FAILURE)} if ((nThreads <= 0) || (nThreads > MAX_NTASKS_NTHREADS)) {fprintf(stderr, "ERROR: thread count should be between [1, %d]\n", MAX_NTASKS_NTHREADS); exit(EXIT_FAILURE); } if (nTasks > 1 && nThreads != nTasks) { fprintf(stderr, "ERROR: thread count should be equal to task count for task count > 1\n"); exit(EXIT_FAILURE);              }  if (nTasks == 1 && nThreads == 1) printf("Running 1 monolitic task...\n"); else if (nTasks == 1 && nThreads > 1)[ line 39/284 (131/27 (3%), char 1251/7755 (1640467811 (100%), char 1304/7755 (16%) ]236 (2%), char 1305354174104 (0%), char 1377/7755 (17%) ]562 (1%), char 1481/7755 (19%) ]661 (100%), char 1543/7755 (19%) ]733 (3%), char 154482 (5077209732 (395023 (460419 (11202833 (32323 (44814910 (10%), char 1664/7755 (21%) ]3823 (4%), char 1648233 (3220179 (110023 (4044932 (3579862 (507733 (3441961 (100%), char 1543/7755 (19%) ]5562 (1%), char 14814104 (0%), char 1377/7755 (17%) ]336 (2%), char 13412405611 (100%), char 1304/7755 (16%) ]026 (3%), char 1278393751{double *data; // Array with dataunsigned int minIndex; // Minimum array index to processunsigned int maxIndex; // Maximum array index to process} threadArgs_t;// Data to be proceeeed by the tasks. One pointer per taskdouble *data[MAX_NTASKS_NTHREADS] ;// Thread function argumentsthreadArgs_t threadArgs[MAX_NTASKS_NTHREADS]; int task(unsigned int taskIndex, unsigned int nTaskThreads, pthread_t threadIDs[]);double mcos(double val);double msin(double val);double mcosh(double val);double msinh(double val);double mexp(double val);double mlog(double val);double msqrt(double val);double mfabs(double val);862557199625 (4745494416 (323309725 (47231047 [ line 30/284 (10%), col 1/84 (1%), char 9632[ line 29/284 (10%), col 1/1 (1002 [ line 28/284 (947 (2%), char 915/7755 (11%) ]729 (388661 (100%), char 885/7755 (11%) ]5836 (2%), char 849/7755 (10%) ]459 (179031 (100%), char 789/7755 (10%) ] [ line 22/284 (7%), col 1/16 (6739%) ]165 (1150657819641 (22382 (501#include <stdio.h>#include <stdlib.h> #include <math.h>#include <pthread.h>#define MAX_NTASKS_NTHREADS 22 // Maximum number of tasks and threads//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write down your DNI without the final letter//////////////////////////////////////////////////////////////////////////////////const unsigned int DNI = ; // Example: const unsigned int DNI = 12345678 const unsigned long NELEMENTS = 55440; // Number of elements to be processed by a task// Structure with the parameters of each threadtypedef struct7515 (6067648 (2558[ line 15/284 (5%), col 1/1 (1007 [ line 14/284 (4%), col 1/87 (14706[ line 13/284 (4%), col 1/1 (10069 [ line 12/284 (4%), col 1/74 (13955138312405425839/284 (3%), col 1/24 (4%), char 2348283 (1151171 (100%), char 150/7755 (1%) ] [ line 6/284 (2%), col 1/70 (18[ line 5/284 (1%), col 1/1 (10079 [ line 4/284 (1%), col 1/21 (4580[ line 5/284 (1%), col 1/1 (100791 [ line 6/284 (2%), col 1/70 (180[ line 7/284 (2%), col 1/1 (100150/7755 (1%) ]883 (1%), char 1519324 (4234310/284 (3%), col 1/54 (1%), char 258/7755 (3%) ]18331242474955[ line 13/284 (4%), col 1/1 (1004696 [ line 14/284 (4%), col 1/87 (170[ line 15/284 (5%), col 1/1 (1005577 [ line 16/284 (5%), col 1/48 (28715 (6606648 (2558[ line 15/284 (5%), col 1/1 (1007 [ line 14/284 (4%), col 1/87 (14706[ line 13/284 (4%), col 1/1 (10069 [ line 14/284 (4%), col 1/87 (170[ line 13/284 (4%), col 1/1 (10069[ line 12/284 (4%), col 74/74 (100%), char 468/7755 (6%) ] [ line 12/284 (4%), col 73/74 (987276155504469338127016/74 (890575946835723612501459/74 (79388277165054494283172061/74 (685074496384273162050394/74 (59838726615504439238127016/74 (480572945834723611500429/74 (3938727616505; // Example: const unsigned int DNI = 12345678 7/75 (361/77563; // Example: const unsigned int DNI = 12345678 8/762/77577; // Example: const unsigned int DNI = 12345678 9/77 (373/775877; // Example: const unsigned int DNI = 12345678 30/78 (384/7759777; // Example: const unsigned int DNI = 12345678 1/79 (395/77602; // Example: const unsigned int DNI = 12345678 2/80 (406/77615; // Example: const unsigned int DNI = 12345678 3/817/77623; // Example: const unsigned int DNI = 12345678 4/82 (418/776331/1 (100%), char 477/7763 (6%) ]434/87 (39%), char 511/7763 (6%) ]551/1 (100%), char 565/7763 (7%) ]634/48 (70%), char 599/7763 (7%) ][ line 17/284 (5%), col 15/15 (106288 [ line 18/284 (6%), col 2/2 (100%), char 630{934/41 (82%), char 657/7763 (8%) ]20765 (59117499[ line 22/284 (7%), col 16/16 (1009610%) ] [ line 23/284 (8%), col 1/1 (100%), char 797[ line 24/284 (8%), col 34/59 (57831536 (94901 [ line 26/284 (9%), col 1/1 (1003[ line 27/284 (9%), col 29/29 (100%), char 922/7763 (11%) ]834/47 (72%), char 956/7763 (12%) ]910%), col 1/1 (10070[ line 30/284 (10%), col 34/84 (41004/7763 (12%) ]125/25 (100%), char 1079/7763 (13%) ]21104436/2630456525/258156206736/2632858697/27854046/26311// Functions to run on each elementconst unsigned int NFUNCTIONS = 10;double (*funcArray[10])(double) = {mcos, msin, mcosh, msinh, mexp, mlog, msqrt, mfabs, mfloor, mceil}; unsigned long NTIMES[10] = {40, 20, 10, 9, 6, 5, 4, 3, 2, 1};int main(int argc, char* argv[]){struct timespec t1, t2;double time12;// Get program argumentsif (argc != 3){fprintf(stderr, "Usage: %s ntasks nthreads\n", argv[0]);exit(EXIT_FAILURE);}unsigned int nTasks = atoi(argv[1]);unsigned int nThreads = atoi(argv[2]);if ((nTasks <= 0) || (nTasks > MAX_NTASKS_NTHREADS)){ [ line 41/284 (14%), col 1/1 (100%), char 1312[ line 42/284 (14%), col 34/36 (9446735824104 (32%), char 1418/7763 (18%) ]562 (54%), char 1522/7763 (19%) ] [ line 46/284 (16%), col 1/1 (10051[ line 47/284 (16%), col 33/33 (100%), char 1584/7763 (20%) ] [ line 48/284 (16%), col 2/2 (100%), char 1586{[ line 49/284 (17%), col 32/32 (100%), char 1611/7763 (20%) ]5023/2327 [ line 51/284 (17%), col 9/9 (100%), char 1629[ line 52/284 (18%), col 33/33 (100%), char 1655/7763 (21%) ]323/2714910/104534/73 (46%), char 169636 (94753272010/10 (100%), char 1758/7763 (22%) ]834/45 (75%), char 178597 (72823360161 (556110/10 (100%), char 1893/7763 (24%) ]fprintf(stderr, "ERROR: task count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if ((nThreads <= 0) || (nThreads > MAX_NTASKS_NTHREADS)){fprintf(stderr, "ERROR: thread count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if (nTasks > 1 && nThreads != nTasks){fprintf(stderr, "ERROR: thread count should be equal to task count for task count > 1\n");exit(EXIT_FAILURE);             }if (nTasks == 1 && nThreads == 1)printf("Running 1 monolitic task...\n");else if (nTasks == 1 && nThreads > 1)printf("Running 1 muktithreaded task...\n");elseprintf("Running %d monolitic tasks, each on a different thread...\n", nTasks);234/103 (33913236 (94%), char 2002/7763 (25%) ]410/10 (100%), char 2007/7763 (25%) ]534/65 (52%), char 2034/7763 (26%) ]6310/10 (100%), char 2068/7763 (26%) ]734/105 (328836 (94%), char 2179/7763 (28%) ]9410/10 (100%), char 2184/7763 (28%) ]7034/46 (73%), char 22111510/10 (100%), char 2226/7763 (28%) ]234/107 (314349 (69%), char 2339/7763 (30%) ]4610/10 (100%), char 2346/7763 (30%) ]57/179634/57 (59%), char 23767740846 (7351961 (5588280813/13 (100%), char 2521/7763 (32%) ]134/95 (35%), char 254 [ line 82/284 (28%), col 1/1 (1006033unsigned int nTaskThreads = nThreads / nTasks; // Number of threads for each taskpthread_t threadIDs[nThreads]; // Thread IDs//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write here the appropiate instructions to start time measurement//////////////////////////////////////////////////////////////////////////////////*** GAP 2 ***// Start all the tasksfor (unsigned int taskIndex = 0; taskIndex < nTasks; taskIndex++){// Each task run nTaskThreads threads and saves their IDs into threads arrayif (task(taskIndex, nTaskThreads, threadIDs) < 0){fprintf(stderr, "Error running the task %d", taskIndex);exit(EXIT_FAILURE);}}// Wait for the threads of all the tasks to finish[ line 83/284 (29%), col 34/90 (3730453 (647134 [ line 85/284 (29%), col 1/1 (10035[ line 86/284 (30%), col 34/91 (376072/32 (100%), char 2842/7763 (36%) ]84/82 (41%), char 28699191 (3794479022/22 (100%), char 3016/7763 (38%) ] [ line 91/284 (32%), col 1/1 (100%), char 3017[ line 90/284 (31%), col 22/22 (100%), char 3016/7763 (38%) ] 1/215/7762 0/204/7761 19/193/7760 8/182/7759 7/171/7758 6/160/7757 5/1509/7756G4/148/7755 3/137/7754 2/126/7753 1/115/7752 0/104/7751   [ line 90/284 (31%), col 9/9 (100%), char 3003/77501/12/77499/93/7750 c[ line 90/284 (31%), col 10/10 (100%), char 3004/7751 (38%) ]l1/115/7752o2/126/7753c3/137/7754k4/148/7755_5/159/7756g6/1610/7757e7/171/7758t8/182/7759t9/193/7760i20/204/7761m1/215/7762e2/226/7763 3/237/7764 2/226/7763(3/237/7764C4/248/7765CL5/259/7766O6/2620/7767C7/271/7768K8/282/7769_9/293/7770R30/304/7771E1/315/7772A2/326/7773L3/337/7774T4/348/7775I5/359/7776M6/3630/7777E7/371/7778)8/382/77797/38 (97%), char 3031,)8/392/7780 )9/403/7781t)40/414/7782)39/403/7781&)40/414/7782t)1/425/7783S)2/436/7784 (39t)3/447/7785a)4/458/7786r)5/469/7787t)6/4740/7788))7/481/7789;)8/492/7790 8 (100%), char 3042/7789 (39%) ]8991 (52%), char 2958/7789 (37%) ]8082 (58883732/32 (100%), char 2842/7789 (36%) ]648/91 (52%), char 2774/7789 (35%) ] [ line 85/284 (29%), col 1/1 (10033[ line 84/284 (29%), col 48/53 (927390 (536443 [ line 82/284 (28%), col 1/1 (10003[ line 81/284 (28%), col 48/95 (55552013/13 (100%), char 2521/7789 (32%) ]79748/61 (78%), char 250286/46 (100%), char 2468/7789 (31%) ]78/57 (84%), char 2420662/57 (733840517/17 (100%), char 2349/7789 (30%) ]40/1063541/49 (83%), char 234228/107 (44%), char 2260/7789 (29%) ]110/10 (1002680446/4636910/101848336/361748/105 (45026610/10 (1000685248/65 (73%), char 204410/10 (100%), char 2007/7789 (25%) ]const unsigned int NFUNCTIONS = 10;double (*funcArray[10])(double) = {mcos, msin, mcosh, msinh, mexp, mlog, msqrt, mfabs, mfloor, mceil}; unsigned long NTIMES[10] = {40, 20, 10, 9, 6, 5, 4, 3, 2, 1};int main(int argc, char* argv[]){struct timespec t1, t2;double time12;// Get program argumentsif (argc != 3){fprintf(stderr, "Usage: %s ntasks nthreads\n", argv[0]);exit(EXIT_FAILURE);}unsigned int nTasks = atoi(argv[1]);unsigned int nThreads = atoi(argv[2]);if ((nTasks <= 0) || (nTasks > MAX_NTASKS_NTHREADS)){fprintf(stderr, "ERROR: task count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);336/3642148/103 (4619274110/10 (100893048/61 (78%), char 18775907/47 (100%), char 1836/7789 (23%) ]85/4579710/1058261936/365548/73 (65%), char 1708/7789 (21%) ]410/10 (100%), char 1674/7789 (21%) ]3823/231233/355 [ line 51/284 (17%), col 9/9 (100%), char 1629/7789 (20%) ][ line 50/284 (17%), col 23/23 (100%), char 1627/7789 (20%) ]4932/3211 [ line 48/284 (16%), col 2/2 (100%), char 1586{[ line 47/284 (16%), col 33/33 (100%), char 1584/7789 (20%) ] [ line 46/284 (16%), col 1/1 (100%), char 1551/7789 (19%) ][ line 45/284 (15%), col 48/62 (77364104 (46%), char 1432/7789 (18%) ]336/36 (1003847} threadArgs_t;// Data to be proceeeed by the tasks. One pointer per taskdouble *data[MAX_NTASKS_NTHREADS] ;// Thread function argumentsthreadArgs_t threadArgs[MAX_NTASKS_NTHREADS]; int task(unsigned int taskIndex, unsigned int nTaskThreads, pthread_t threadIDs[]);double mcos(double val);double msin(double val);double mcosh(double val);double msinh(double val);double mexp(double val);double mlog(double val);double msqrt(double val);double mfabs(double val);double mfloor(double val);double mceil(double val);// Functions to run on each element [ line 42/284 (14%), col 36/36 (100%), char 1348/7789 (17%) ] [ line 41/284 (14%), col 1/1 (100%), char 1312/7789 (16%) ][ line 40/284 (14%), col 26/26 (100%), char 1311/7789 (16%) ]3937/2728586/26587325625/25065181416/2656433025/2504100793048/84 (57%), char 1018 [ line 29/284 (10%), col 1/1 (100970/7789 (12%) ]89%), col 47/47 (100%), char 969/7789 (12%) ]729/29221 [ line 26/284 (9%), col 1/1 (100%), char 893[ line 25/284 (8%), col 36/36 (100%), char 892/7789 (11%) ]448/59 (81%), char 845/7789 (10%) ] [ line 23/284 (8%), col 1/1 (100797[ line 22/284 (7%), col 16/16 (100%), char 796/7789 (10%) ]#include <stdio.h>#include <stdlib.h> #include <math.h>#include <pthread.h>#define MAX_NTASKS_NTHREADS 22 // Maximum number of tasks and threads//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write down your DNI without the final letter//////////////////////////////////////////////////////////////////////////////////const unsigned int DNI = 53777253; // Example: const unsigned int DNI = 12345678 const unsigned long NELEMENTS = 55440; // Number of elements to be processed by a task// Structure with the parameters of each threadtypedef struct{double *data; // Array with dataunsigned int minIndex; // Minimum array index to processunsigned int maxIndex; // Maximum array index to process [ line 21/284 (7%), col 48/65 (73639%) ]005[ line 19/284 (6%), col 41/41 (1006648 [ line 18/284 (6%), col 2/2 (100%), char 630{[ line 19/284 (6%), col 41/41 (100%), char 664/7789 (8%) ] [ line 20/284 (7%), col 48/65 (737059163[ line 22/284 (7%), col 16/16 (1009610%) ] [ line 23/284 (8%), col 1/1 (100%), char 797[ line 24/284 (8%), col 48/59 (81845536/36 (100%), char 892/7789 (11%) ] [ line 26/284 (9%), col 1/1 (100%), char 893[ line 27/284 (9%), col 29/29 (100%), char 922/7789 (11%) ]847/47692910%), col 1/1 (100%), char 970[ line 30/284 (10%), col 48/84 (571018/7789 (13%) ]125/25 (100%), char 1079/7789 (13%) ]21104436/2630456525/258156206736/2632858697/27854046/26311// Functions to run on each elementconst unsigned int NFUNCTIONS = 10;double (*funcArray[10])(double) = {mcos, msin, mcosh, msinh, mexp, mlog, msqrt, mfabs, mfloor, mceil}; unsigned long NTIMES[10] = {40, 20, 10, 9, 6, 5, 4, 3, 2, 1};int main(int argc, char* argv[]){struct timespec t1, t2;double time12;// Get program argumentsif (argc != 3){fprintf(stderr, "Usage: %s ntasks nthreads\n", argv[0]);exit(EXIT_FAILURE);}unsigned int nTasks = atoi(argv[1]);unsigned int nThreads = atoi(argv[2]);if ((nTasks <= 0) || (nTasks > MAX_NTASKS_NTHREADS)){ [ line 41/284 (14%), col 1/1 (100%), char 1312[ line 42/284 (14%), col 36/36 (100%), char 1348/7789 (17%) ]3584448/104 (464328562 (77%), char 1536/7789 (19%) ] [ line 46/284 (16%), col 1/1 (10051[ line 47/284 (16%), col 33/33 (100%), char 1584/7789 (20%) ] [ line 48/284 (16%), col 2/2 (100%), char 1586{[ line 49/284 (17%), col 32/32 (100%), char 1611/7789 (20%) ]5023/2327 [ line 51/284 (17%), col 9/9 (100%), char 1629[ line 52/284 (18%), col 33/33 (100%), char 1655/7789 (21%) ]323/2714910/104548/73 (65%), char 1708636/36 (100%), char 1755/7789 (22%) ]72010/108845/4596397/47836018/61 (78%), char 1877/7789 (24%) ]110/10 (100%), char 1893/7789 (24%) ]fprintf(stderr, "ERROR: task count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if ((nThreads <= 0) || (nThreads > MAX_NTASKS_NTHREADS)){fprintf(stderr, "ERROR: thread count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if (nTasks > 1 && nThreads != nTasks){fprintf(stderr, "ERROR: thread count should be equal to task count for task count > 1\n");exit(EXIT_FAILURE);             }if (nTasks == 1 && nThreads == 1)printf("Running 1 monolitic task...\n");else if (nTasks == 1 && nThreads > 1)printf("Running 1 muktithreaded task...\n");elseprintf("Running %d monolitic tasks, each on a different thread...\n", nTasks);248/103 (469273236/36 (10020045410/107548/65 (73%), char 2048/7789 (26%) ]6310/10 (100%), char 2068/7789 (26%) ]748/105 (45102836/36 (1008189410/1047046/462231510/106248/107 (4460931/49 (83%), char 2342/7789 (30%) ]4610/10 (100%), char 2346/7789 (30%) ]57/179642/57 (73%), char 2384778/57 (84420186/46 (100%), char 2468/7789 (31%) ]98/61 (78%), char 2502/7789 (32%) ]80813/13 (100%), char 2521/7789 (32%) ]148/95 (50%), char 2555 [ line 82/284 (28%), col 1/1 (106033unsigned int nTaskThreads = nThreads / nTasks; // Number of threads for each taskpthread_t threadIDs[nThreads]; // Thread IDs//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write here the appropiate instructions to start time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &tStart);// Start all the tasksfor (unsigned int taskIndex = 0; taskIndex < nTasks; taskIndex++){// Each task run nTaskThreads threads and saves their IDs into threads arrayif (task(taskIndex, nTaskThreads, threadIDs) < 0){fprintf(stderr, "Error running the task %d", taskIndex);exit(EXIT_FAILURE);}}// Wait for the threads of all the tasks to finish[ line 83/284 (29%), col 48/90 (5344453 (907275 [ line 85/284 (29%), col 1/1 (1033[ line 86/284 (30%), col 48/91 (5274732/32 (100%), char 2842/7789 (36%) ]848/82 (58%), char 2883/7789 (37%) ]9191 (529589048 (100%), char 3042/7789 (39%) ] [ line 91/284 (32%), col 1/1 (100%), char 3043[ line 92/284 (32%), col 31/31 (100%), char 3067/7789 (39%) ]348/74 (64%), char 31084310/10 (100%), char 3137/7789 (40%) ]548/93 (51%), char 3171666 (7225017418/18 (100%), char 3272/7789 (42%) ]848/81 (59%), char 329994/44 (100%), char 3355/7789 (43%) ][ line 100518/18910/1062 [ line 102/284 (35%), col 9/9 (100%), char 33643648/59 (81%), char 3405/7789 (43%) ]for (unsigned int threadIndex = 0; threadIndex < nThreads; threadIndex++)pthread_join(threadIDs[threadIndex], NULL);// Free memmoryfor (unsigned taskIndex = 0; taskIndex < nTasks; taskIndex++)if (data[taskIndex] != NULL)free(data[taskIndex]);//////////////////////////////////////////////////////////////////////////////////// Finish measuring time// TODO: Write here the appropiate instructions to finish time measurement//////////////////////////////////////////////////////////////////////////////////*** GAP 3 ***printf("Execution finished\n");//////////////////////////////////////////////////////////////////////////////////// Show the elapsed time// TODO: Write here the appropiate instructions to calculate the elapsed time//////////////////////////////////////////////////////////////////////////////////*** GAP 4 ***482 (58574560 (805255671/1 (100%), char 3538[ line 107/284 (37%), col 24/24 (100%), char 3555/7789 (45%) ] [ line 108/284 (38%), col 48/70 (68966[ line 109/284 (38%), col 45/45 (100649107/47757 [ line 111/284 (39%), col 1/1 (100%), char 3676248/91 (52%), char 3717/7789 (47%) ][ line 113/284 (39%), col 33/33 (100868 [ line 114/284 (40%), col 48/83 (578279591 (5290350[ line 116/284 (40%), col 22/22 (10061 [ line 117/284 (41%), col 9/9 (100%), char 3963[ line 118/284 (41%), col 40/40 (100%), char 3996/7789 (51%) ] [ line 119/284 (41%), col 1/1 (100%), char 399720248/91 (52%), char 4038/7789 (51%) ][ line 121/284 (42%), col 33/33 (1001072 [ line 122/284 (42%), col 48/86 (554833391 (522274[ line 124/284 (43%), col 22/22 (100855printf("Elapsed time    : %f s.\n", time12);return 0;}// Return a random number in the interval [min, max]double get_random(unsigned int min, unsigned int max){return min + (max - min) * ((double)rand()/(double)RAND_MAX);}// Function called by every threadvoid *thread_job(void *args){threadArgs_t *threadArgs = (threadArgs_t *)args;double *dta = threadArgs->data;unsigned int minIndex = threadArgs->minIndex;unsigned int maxIndex = threadArgs->maxIndex;unsigned int nTimesIndex = DNI % 10;541/2192 [ line 126/284 (44%), col 48/53 (933379/9 (100%), char 4340[ line 128/284 (45%), col 18/18 (100%), char 4351/7789 (55%) ] [ line 129/284 (45%), col 2/2 (100%), char 4353}301/141648/53 (90%), char 4402/7789 (56%) ]24 (8855732/2 (100%), char 4463{4748/70 (68%), char 4504/7789 (57%) ]52/2 (100%), char 4528/7789 (58%) ]}61/1952/28448/70 (68%), char 4504/7789 (57%) ]362/2 (100%), char 4463{248/54 (88%), char 4455/7789 (57%) ]13 (90026051/1 (100%), char 4354/7789 (55%) ]292/23[ line 128/284 (45%), col 18/18 (100%), char 4351/7789 (55%) ] [ line 127/284 (44%), col 9/9 (100%), char 4340648/53 (90%), char 4333/7789 (55%) ][ line 125/284 (44%), col 21/21 (10292432/2285 [ line 123/284 (43%), col 48/91 (522742286 (551483[ line 121/284 (42%), col 33/33 (100072 [ line 120/284 (42%), col 48/91 (5203811911/1 (100%), char 3997[ line 118/284 (41%), col 40/40 (100%), char 3996/7789 (51%) ] [ line 117/284 (41%), col 9/9 (100%), char 3963/7789 (50%) ][ line 116/284 (40%), col 22/22 (100%), char 3961/7789 (50%) ] [ line 115/284 (40%), col 48/91 (5203483 (5782749[ line 113/284 (39%), col 33/33 (1007868 [ line 112/284 (39%), col 48/91 (5217711/1 (100%), char 3676[ line 110/284 (38%), col 47/47 (100%), char 3675/7789 (47%) ]095/45496 [ line 108/284 (38%), col 48/70 (68596[ line 107/284 (37%), col 24/24 (100555 [ line 106/284 (37%), col 1/1 (100%), char 3538//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write here the appropiate instructions to start time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &tStart);// Start all the tasksfor (unsigned int taskIndex = 0; taskIndex < nTasks; taskIndex++){// Each task run nTaskThreads threads and saves their IDs into threads arrayif (task(taskIndex, nTaskThreads, threadIDs) < 0){fprintf(stderr, "Error running the task %d", taskIndex);exit(EXIT_FAILURE);}}// Wait for the threads of all the tasks to finishfor (unsigned int threadIndex = 0; threadIndex < nThreads; threadIndex++)pthread_join(threadIDs[threadIndex], NULL);5648/60 (80%), char 3525/7789 (45%) ]482 (584574359 (81053259/9 (100%), char 3364[ line 101/284 (35%), col 10/10 (100%), char 3362/7789 (43%) ]08/185910/1062 [ line 102/284 (35%), col 9/9 (100%), char 33643648/59 (81%), char 3405/7789 (43%) ]482 (58574560 (805255671/1 (100%), char 3538[ line 107/284 (37%), col 24/24 (100%), char 3555/7789 (45%) ] [ line 108/284 (38%), col 48/70 (68966[ line 109/284 (38%), col 45/45 (100649107/47757 [ line 111/284 (39%), col 1/1 (100%), char 3676248/91 (52%), char 3717/7789 (47%) ][ line 113/284 (39%), col 33/33 (100868 [ line 114/284 (40%), col 48/83 (578279591 (5290350[ line 116/284 (40%), col 22/22 (10061 1/210/7788 0/2059/7787 19/198/7786 8/187/7785 7/176/7784 6/165/7783 5/154/7782G4/143/7781 3/132/7780 2/121/7779 1/110/7778 0/1049/7777   [ line 116/284 (40%), col 9/9 (100%), char 3948/7776 c[ line 116/284 (40%), col 10/10 (100%), char 3949/7777 (50%) ]l1/1150/7778o2/121/7779c3/132/7780k4/143/7781_5/154/7782g6/165/7783e7/176/7784t8/187/7785t9/198/7786i20/209/7787m1/2160/7788e2/221/7789(3/232/7790C4/243/7791CL5/254/7792O6/265/7793C7/276/7794CLOCk8/287/7795CLOC7/276/7794K8/287/7795_9/298/7796R30/309/7797E1/3170/7798A2/321/7799L3/332/7800T4/343/7801I5/354/7802M6/365/7803E7/376/7804)8/387/7805 7/376/7804,8/387/7805 9/398/7806 &40/409/7807y1/4180/7808 0/4079/7807 39/398/7806 t40/409/7807 39/398/7806 &40/409/7807t1/4180/7808S2/421/7809 1/410/7808E2/421/7809n3/432/7810d4/443/7811)5/454/7812;6/465/7813 (51 [ line 117/284 (41%), col 9/9 (100%), char 3987[ line 118/284 (41%), col 40/40 (100%), char 4020/7813 (51%) ] [ line 119/284 (41%), col 1/1 (100%), char 402120246/91 (50%), char 4060/7813 (51%) ][ line 121/284 (42%), col 33/33 (101312 [ line 122/284 (42%), col 46/86 (537033391 (502494[ line 124/284 (43%), col 22/22 (10305 1/218/7812 0/207/7811 19/196/7810 8/185/7809 7/174/7808 6/163/7807 5/152/7806G4/141/7805 3/130/7804 2/12299/7803 1/118/7802 0/107/7801   [ line 124/284 (43%), col 9/9 (100%), char 4296/7800printf("Elapsed time    : %f s.\n", time12);return 0;}// Return a random number in the interval [min, max]double get_random(unsigned int min, unsigned int max){return min + (max - min) * ((double)rand()/(double)RAND_MAX);}// Function called by every threadvoid *thread_job(void *args){threadArgs_t *threadArgs = (threadArgs_t *)args;double *dta = threadArgs->data;unsigned int minIndex = threadArgs->minIndex;unsigned int maxIndex = threadArgs->maxIndex;unsigned int nTimesIndex = DNI % 10;5421 (428439 (1006 [ line 123/284 (43%), col 9/91 (9124[ line 124/284 (43%), col 9/9 (100965dElapsedTimeS = (tEnd.tv_sec - tStart.tv_sec);dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;== -1[ line 125/285 (43%), col 62/62 (100%), char 4404/7908 (55%) ]   5/655/7909 [ line 125/285 (43%), col 62/65 (95413302259018/65 (890773996685474363152041/65 (783062495183072896085/65 (69747636524413301239018/65 (58076796585374263052/65 (494173062294183071696085/65 (38746635523412300219/65 (29187076596485374163052/65 (1841630529/65 (13%), char 435182070494 [ line 125/285 (43%), col 6/65 (985/65 (774/65 (663/65 (452/65 (341/65 (13 dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;== -1   [ line 125/285 (43%), col 9/73 (124/79106421 (44085Save modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                                                                                  Y Yes N No   ^C CancelFile Name to Write: program.c                               ^G Get HelpM-D DOS FormatM-A AppendM-B Backup File^C Cancel            M-M Mac FormatM-P Prepend^T To Files [ Wrote 284 lines ]        student@2ac:~$ sudop  gcc programa.c m.c am.c -c prograo program -lm -lpthread
program.c: In function main:
program.c:90:33: error: tStart undeclared (first use in this function)
  clock_gettime(CLOCK_REALTIME, &tStart);
                                 ^
program.c:90:33: note: each undeclared identifier is reported only once for each function it appears in
program.c:116:33: error: tEnd undeclared (first use in this function)
  clock_gettime(CLOCK_REALTIME, &tEnd);
                                 ^
program.c:124:2: error: dElapsedTimeS undeclared (first use in this function)
  dElapsedTimeS = (tEnd.tv_sec - tStart.tv_sec);
  ^
program.c:125:58: error: expected expression before == token
  dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;== -1 
                                                          ^
student@2ac:~$ sudo gcc program.c -o program -lm -lpthreadnano -c program.c
[ Reading File ][ Read 284 lines ]  GNU nano 2.5.3                                  File: program.c                                                                            #include <stdio.h>#include <stdlib.h> #include <math.h>#include <pthread.h>#define MAX_NTASKS_NTHREADS 22 // Maximum number of tasks and threads//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write down your DNI without the final letter//////////////////////////////////////////////////////////////////////////////////const unsigned int DNI = 53777253; // Example: const unsigned int DNI = 12345678 const unsigned long NELEMENTS = 55440; // Number of elements to be processed by a task// Structure with the parameters of each threadtypedef struct{double *data; // Array with dataunsigned int minIndex; // Minimum array index to processunsigned int maxIndex; // Maximum array index to process} threadArgs_t;// Data to be proceeeed by the tasks. One pointer per taskdouble *data[MAX_NTASKS_NTHREADS] ;// Thread function argumentsthreadArgs_t threadArgs[MAX_NTASKS_NTHREADS]; int task(unsigned int taskIndex, unsigned int nTaskThreads, pthread_t threadIDs[]);double mcos(double val);double msin(double val);double mcosh(double val);double msinh(double val);double mexp(double val);double mlog(double val);double msqrt(double val);double mfabs(double val);double mfloor(double val);double mceil(double val);^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     ^Y Prev Page   M-\ First Line M-W WhereIs Next^X Exit^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  ^V Next Page   M-/ Last Line  M-] To Bracket[ line 2/285 (0%), col 1/21 (4%), char 19/7910 (0%) ]3118 (540421 (458[ line 5/285 (1%), col 1/1 (10079 [ line 6/285 (2%), col 1/70 (1801[ line 7/285 (2%), col 1/1 (100150/7910 (1%) ]883 (1%), char 1519324 (4234210/285 (3%), col 1/54 (1%), char 258/7910 (3%) ]183312242954[ line 13/285 (4%), col 1/1 (1004776 [ line 14/285 (4%), col 1/87 (18[ line 15/285 (5%), col 1/1 (1005657 [ line 16/285 (5%), col 1/48 (26715 (6614862 (5029941 (23120765 (165817239216 (681[ line 23/285 (8%), col 1/1 (1009710%) ]459 (1%), char 798536 (2857691 (100%), char 893/7910 (11%) ]729 (3%), char 894847 (2923[ line 29/285 (101 (100%), char 970/7910 (12%) ] [ line 30/285 (10%), col 1/84 (11[ line 31/285 (10%), col 1/25 (4%), char 10553218036 (31054314525 (45768276 (32075833397594046866// Functions to run on each elementconst unsigned int NFUNCTIONS = 10;double (*funcArray[10])(double) = {mcos, msin, mcosh, msinh, mexp, mlog, msqrt, mfabs, mfloor, mceil}; unsigned long NTIMES[10] = {40, 20, 10, 9, 6, 5, 4, 3, 2, 1};int main(int argc, char* argv[]){struct timespec t1, t2;double time12;// Get program argumentsif (argc != 3){fprintf(stderr, "Usage: %s ntasks nthreads\n", argv[0]);exit(EXIT_FAILURE);}unsigned int nTasks = atoi(argv[1]);unsigned int nThreads = atoi(argv[2]);if ((nTasks <= 0) || (nTasks > MAX_NTASKS_NTHREADS)){11 (100%), char 1312/7910 (16%) ]236 (2%), char 1313354974104 (0%), char 1385/7910 (17%) ]562 (1%), char 1489/7910 (18%) ]661 (100%), char 1551/7910 (19%) ]733 (3%), char 155282 (5085209732 (375023 (461219 (11282833 (330323 (456410 (10%), char 1672/7910 (21%) ]5973 (1%), char 1675636 (273472010 (10%), char 1756/7910 (22%) ]845 (2%), char 1759979760161 (1833110 (10%), char 1891/7910 (23%) ]fprintf(stderr, "ERROR: task count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if ((nThreads <= 0) || (nThreads > MAX_NTASKS_NTHREADS)){fprintf(stderr, "ERROR: thread count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if (nTasks > 1 && nThreads != nTasks){fprintf(stderr, "ERROR: thread count should be equal to task count for task count > 1\n");exit(EXIT_FAILURE);             }if (nTasks == 1 && nThreads == 1)printf("Running 1 monolitic task...\n");else if (nTasks == 1 && nThreads > 1)printf("Running 1 muktithreaded task...\n");elseprintf("Running %d monolitic tasks, each on a different thread...\n", nTasks);23 (43236 (2%), char 1983/7910 (25%) ]410 (10%), char 2005/7910 (25%) ]565 (1%), char 20086310 (10%), char 2066/7910 (26%) ]75 (9836 (2%), char 2160/7910 (27%) ]9410 (10%), char 2182/7910 (27%) ]7046 (2%), char 2185110 (10%), char 2224/7910 (28%) ]257 (7349 (2%), char 2320/7910 (29%) ]410 (10%), char 2344/7910 (29%) ]567 (5%), char 2347657 (150778730846 (2430961 (169180813 (7516195 (12221 (100%), char 2603/7910 (32%) ]unsigned int nTaskThreads = nThreads / nTasks; // Number of threads for each taskpthread_t threadIDs[nThreads]; // Thread IDs//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write here the appropiate instructions to start time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &tStart);// Start all the tasksfor (unsigned int taskIndex = 0; taskIndex < nTasks; taskIndex++){// Each task run nTaskThreads threads and saves their IDs into threads arrayif (task(taskIndex, nTaskThreads, threadIDs) < 0){fprintf(stderr, "Error running the task %d", taskIndex);exit(EXIT_FAILURE);}}// Wait for the threads of all the tasks to finish3990 (1%), char 260445387351 (100%), char 2733/7910 (34%) ]63091 (1%), char 2734732 (38185882 (143919191869048 (23002711 (100%), char 3043/7910 (38%) ]2231 (3%), char 3044374 (168410 (10%), char 3135/7910 (39%) ]5393 (1%), char 3138666217407418 (5691881 (173944 (2332100/285 (35%), col 1/18 (5%), char 3356/7910 (42%) ][ line 101/285 (35%), col 1/10 (1060 [ line 102/285 (35%), col 1/9 (1133659 (5for (unsigned int threadIndex = 0; threadIndex < nThreads; threadIndex++)pthread_join(threadIDs[threadIndex], NULL);// Free memmoryfor (unsigned taskIndex = 0; taskIndex < nTasks; taskIndex++)if (data[taskIndex] != NULL)free(data[taskIndex]);//////////////////////////////////////////////////////////////////////////////////// Finish measuring time// TODO: Write here the appropiate instructions to finish time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &tEnd);printf("Execution finished\n");//////////////////////////////////////////////////////////////////////////////////// Show the elapsed time// TODO: Write here the appropiate instructions to calculate the elapsed time//////////////////////////////////////////////////////////////////////////////////dElapsedTimeS = (tEnd.tv_sec - tStart.tv_sec);4824173560924[ line 106/285 (37%), col 1/1 (100538 [ line 107/285 (37%), col 1/24 (49870 (1569845 (26195107506[ line 111/285 (38%), col 1/1 (10076 [ line 112/285 (39%), col 1/91 (17333 (3761744083 (1875918638646 (29479719 (118650840 (28[ line 119/285 (41%), col 1/1 (1004021 [ line 120/285 (42%), col 1/91 (12133 (31061286 (132233912113455954dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;== -1   printf("Elapsed time    : %f s.\n", time12);return 0;}// Return a random number in the interval [min, max]double get_random(unsigned int min, unsigned int max){return min + (max - min) * ((double)rand()/(double)RAND_MAX);}// Function called by every threadvoid *thread_job(void *args){threadArgs_t *threadArgs = (threadArgs_t *)args;double *dta = threadArgs->data;unsigned int minIndex = threadArgs->minIndex;unsigned int maxIndex = threadArgs->maxIndex;unsigned int nTimesIndex = DNI % 10;5733436421 (44075[ line 126/285 (44%), col 9/21 (42817/21 (80%), char 4409/7910 (55%) ]85109/21 (9012052[ line 126/285 (44%), col 21/21 (1003  [ line 127/285 (44%), col 1/53 (1%), char 4414[ line 127/285 (44%), col 9/53 (16510/53 (18%), char 4416/7910 (55%) ]69/21 (42%), char 4408 [ line 126/285 (44%), col 1/21 (47[ line 125/285 (43%), col 73/73 (100%), char 4406/7910 (55%) ] [ line 125/285 (43%), col 70/73 (9556944Modified1 833/79091 712/79081 601/79071 5/73 (890/7906 5[ line 126/285 (44%), col 21/21 (1008 [ line 125/285 (43%), col 65/73 (890[ line 124/285 (43%), col 55/55 (1003424 [ line 124/285 (43%), col 54/55 (981573 (73895[ line 126/285 (44%), col 21/21 (100408753/53546 [ line 127/285 (44%), col 52/53 (983162041492080497/53 (888667546[ line 126/285 (44%), col 21/21 (100085 [ line 126/285 (44%), col 20/21 (9575373 (27355186455 (3084391 (2322432286 (241452133 (6319091 (203511911/1 (100%), char 4021/7905 (50%) ]821/40 (52%), char 4001/7905 (50%) ]79/9 (100%), char 39876021/46 (45%), char 3960/7905 (50%) ]591 (2387649483 (2500833933 (637747291 (26906181/1 (100%), char 367607/47 (36%), char 3652/7905 (46%) ]0921/45 (42558770 (30569724 (8752461/1 (100%), char 3538//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write here the appropiate instructions to start time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &tStart);// Start all the tasksfor (unsigned int taskIndex = 0; taskIndex < nTasks; taskIndex++){// Each task run nTaskThreads threads and saves their IDs into threads arrayif (task(taskIndex, nTaskThreads, threadIDs) < 0){fprintf(stderr, "Error running the task %d", taskIndex);exit(EXIT_FAILURE);}}// Wait for the threads of all the tasks to finishfor (unsigned int threadIndex = 0; threadIndex < nThreads; threadIndex++)pthread_join(threadIDs[threadIndex], NULL);5621/60 (35%), char 3498/7905 (44%) ]482 (2303359 (33782259/9 (100%), char 3364[ line 101/285 (35%), col 10/10 (100%), char 3362/7905 (42%) ]08/1859 [ line 9947/44 (38%), char 3335881 (2027178/18 (100%), char 3272/7905 (41%) ]6321/66 (31%), char 3223/7905 (40%) ]593 (22144394210/10 (100%), char 3137/7905 (39%) ]321/74 (28%), char 3081/7905 (38%) ]231 (6757 [ line 91/285 (31%), col 1/1 (10043[ line 90/285 (31%), col 21/48 (43158991 (2293178082 (258566732 (6315691 (237474 [ line 85/285 (29%), col 1/1 (10033}if ((nThreads <= 0) || (nThreads > MAX_NTASKS_NTHREADS)){fprintf(stderr, "ERROR: thread count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if (nTasks > 1 && nThreads != nTasks){fprintf(stderr, "ERROR: thread count should be equal to task count for task count > 1\n");exit(EXIT_FAILURE);             }if (nTasks == 1 && nThreads == 1)printf("Running 1 monolitic task...\n");else if (nTasks == 1 && nThreads > 1)printf("Running 1 muktithreaded task...\n");elseprintf("Running %d monolitic tasks, each on a different thread...\n", nTasks);unsigned int nTaskThreads = nThreads / nTasks; // Number of threads for each taskpthread_t threadIDs[nThreads]; // Thread IDs[ line 84/285 (29%), col 21/53 (3900390 (236173 [ line 82/285 (28%), col 1/1 (100032[ line 81/285 (28%), col 21/95 (225281013/13 (100%), char 2521/7905 (31%) ]79721/61 (34%), char 2475846 (45430757 (363966629517/17 (100%), char 2349/7905 (29%) ]450/106321/49 (42%), char 232410/10 (100%), char 2346/7905 (29%) ]321/49 (42%), char 2322107 (19%), char 2233/7905 (28%) ]1410/10 (10026021/46 (45%), char 2198/7905 (27%) ]6910/10 (100%), char 2184/7905 (27%) ]8321/36 (58%), char 21667105 (20%), char 2075/7905 (26%) ]610/10 (10685221/65 (32%), char 2021/7905 (25%) ]410/10 (100%), char 2007/7905 (25%) ]const unsigned int NFUNCTIONS = 10;double (*funcArray[10])(double) = {mcos, msin, mcosh, msinh, mexp, mlog, msqrt, mfabs, mfloor, mceil}; unsigned long NTIMES[10] = {40, 20, 10, 9, 6, 5, 4, 3, 2, 1};int main(int argc, char* argv[]){struct timespec t1, t2;double time12;// Get program argumentsif (argc != 3){fprintf(stderr, "Usage: %s ntasks nthreads\n", argv[0]);exit(EXIT_FAILURE);}unsigned int nTasks = atoi(argv[1]);unsigned int nThreads = atoi(argv[2]);if ((nTasks <= 0) || (nTasks > MAX_NTASKS_NTHREADS)){fprintf(stderr, "ERROR: task count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);321/36 (58%), char 1989410/10 (100%), char 2007/7905 (25%) ]521/65 (32%), char 20216310/10 (100%), char 2068/7905 (26%) ]721/105 (275836 (58%), char 2166/7905 (27%) ]9410/10 (100%), char 2184/7905 (27%) ]7021/46 (45%), char 2198110/10 (100%), char 2226/7905 (28%) ]2521/107 (1933349 (42%), char 2326/7905 (29%) ]410/10 (100%), char 2346/7905 (29%) ]567/179621/57 (36%), char 236377930846 (4544961 (3475180813/13 (100%), char 2521/7905 (31%) ]121/95 (22%), char 2528 [ line 82/285 (28%), col 1/1 (1006032unsigned int nTaskThreads = nThreads / nTasks; // Number of threads for each taskpthread_t threadIDs[nThreads]; // Thread IDs//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write here the appropiate instructions to start time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &tStart);// Start all the tasksfor (unsigned int taskIndex = 0; taskIndex < nTasks; taskIndex++){// Each task run nTaskThreads threads and saves their IDs into threads arrayif (task(taskIndex, nTaskThreads, threadIDs) < 0){fprintf(stderr, "Error running the task %d", taskIndex);exit(EXIT_FAILURE);}}// Wait for the threads of all the tasks to finish[ line 83/285 (29%), col 21/90 (23173453 (397004 [ line 85/285 (29%), col 1/1 (10033[ line 86/285 (30%), col 21/91 (2347732 (658315882 (25669191 (2393179048 (4301582563774/48 (50852964207618829/48 (60330241452663874/48 (70852965307718929/48 (81340341557 (8746 (893rt);5 (912t);4 (931t);3 (9503/43 (100%), char 3037/7900 (38%) ]2/43 (97%), char 30361551);2/446/7901 [ line 91/285 (31%), col 1/1 (1009[ line 92/285 (32%), col 31/31 (100%), char 3063/7901 (38%) ]342/74 (56%), char 3098/7901 (39%) ]410/10 (100%), char 3133/7901 (39%) ]5342/93 (45%), char 3161/7901 (40%) ]666 (6324017418/18 (100%), char 3268/7901 (41%) ]842/81 (51%), char 3289944 (95342[ line 100518/18 (100%), char 3355/7901 (42%) ]10/10808/185 [ line 99442/44 (95%), char 3349[ line 100518/18 (100%), char 3355/7901 (42%) ]10/108 [ line 102/285 (35%), col 9/9 (100%), char 33603642/59 (71%), char 3395/7901 (42%) ]for (unsigned int threadIndex = 0; threadIndex < nThreads; threadIndex++)pthread_join(threadIDs[threadIndex], NULL);// Free memmoryfor (unsigned taskIndex = 0; taskIndex < nTasks; taskIndex++)if (data[taskIndex] != NULL)free(data[taskIndex]);//////////////////////////////////////////////////////////////////////////////////// Finish measuring time// TODO: Write here the appropiate instructions to finish time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &tEnd);printf("Execution finished\n");//////////////////////////////////////////////////////////////////////////////////// Show the elapsed time// TODO: Write here the appropiate instructions to calculate the elapsed time//////////////////////////////////////////////////////////////////////////////////dElapsedTimeS = (tEnd.tv_sec - tStart.tv_sec);482 (54473560 (705154671/1 (100%), char 3534[ line 107/285 (37%), col 24/24 (100%), char 3551/7901 (44%) ] [ line 108/285 (37%), col 42/70 (68659845 (936426107 (896611/1 (100%), char 36722942/91 (46%), char 3707/7901 (46%) ][ line 113/285 (39%), col 33/33 (100827 [ line 114/285 (40%), col 42/83 (58178591 (46939646 (9197750719/9 (100%), char 39836042/46 (91%), char 3977/7901 (50%) ]1/46 (896nd);5 (910d);4 (93899);3 (9582);2/447/7899719/9 (100%), char 3981[ line 118/285 (41%), col 40/40 (100%), char 4014/7899 (50%) ] [ line 119/285 (41%), col 1/1 (100%), char 401520242/91 (46%), char 4050/7899 (51%) ][ line 121/285 (42%), col 33/33 (1001252 [ line 122/285 (42%), col 42/86 (48603391 (462393455 (7323414202139008/55 (69197786575364153042/55 (583162041292080097/55 (4986777984 (508372 (5162.tv_sec - tStart.tv_sec);8/53 (529/7897941030611822/53 (6033244455666777988/53 (7199320405139302 (7561 (7650 (78449 (7938 (8121.tv_sec);40/491/7893dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;        printf("Elapsed time    : %f s.\n", time12);return 0;}// Return a random number in the interval [min, max]double get_random(unsigned int min, unsigned int max){return min + (max - min) * ((double)rand()/(double)RAND_MAX);}// Function called by every threadvoid *thread_job(void *args){threadArgs_t *threadArgs = (threadArgs_t *)args;double *dta = threadArgs->data;unsigned int minIndex = threadArgs->minIndex;unsigned int maxIndex = threadArgs->maxIndex;unsigned int nTimesIndex = DNI % 10;573 (5463539328217006/73 (495957846735623512401329/73 (3928817606549548427449 (480543642431220/48 (411/789219/47 (400/78918/46 (39299/78907/45 (378/78896/44 (367/78885/43 (346/78872 (3564/41 (345/78853/40 (324/78842/39 (303/78831/38 (282/78820/37 (271/78819/36 (25%), char 4290/7880t = (t2.tv_sec - t1.tv_sec);10/37 (27%), char 4291/7881 (54%) ]i = (t2.tv_sec - t1.tv_sec);1/38 (282/7882m = (t2.tv_sec - t1.tv_sec);2/39 (303/7883e = (t2.tv_sec - t1.tv_sec);3/40 (324/78842 = (t2.tv_sec - t1.tv_sec);4/41 (345/78853 = (t2.tv_sec - t1.tv_sec);5/42 (356/78864/41 (345/78853/40 (324/78841 = (t2.tv_sec - t1.tv_sec);4/41 (345/78852 = (t2.tv_sec - t1.tv_sec);5/42 (356/7886573 (203314/73 (19037292681570369/73 (12%), char 4325ElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 65 (135lapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 4apsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 3psedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 2sedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 1edTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 0dTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 79TimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 8imeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 57 (157meS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 6eS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 5S += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 4 += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9; 3t += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;10/57 (17%), char 4326/7874 (54%) ]i += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;197/7875m += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;2/57 (218/7876e += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;329/78771 += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;        4/65 (2130/78782 += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;531/7879642763874599520/65 (30612700619/65 (295874763464253141030292/65 (1881670569/65 (13%), char 4325Save modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                                                                                  Y Yes N No   ^C Cancelstudent@2ac:~$ sudo nano -c program.c
[ Reading File ][ Read 284 lines ]  GNU nano 2.5.3                                  File: program.c                                                                            #include <stdio.h>#include <stdlib.h> #include <math.h>#include <pthread.h>#define MAX_NTASKS_NTHREADS 22 // Maximum number of tasks and threads//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write down your DNI without the final letter//////////////////////////////////////////////////////////////////////////////////const unsigned int DNI = 53777253; // Example: const unsigned int DNI = 12345678 const unsigned long NELEMENTS = 55440; // Number of elements to be processed by a task// Structure with the parameters of each threadtypedef struct{double *data; // Array with dataunsigned int minIndex; // Minimum array index to processunsigned int maxIndex; // Maximum array index to process} threadArgs_t;// Data to be proceeeed by the tasks. One pointer per taskdouble *data[MAX_NTASKS_NTHREADS] ;// Thread function argumentsthreadArgs_t threadArgs[MAX_NTASKS_NTHREADS]; int task(unsigned int taskIndex, unsigned int nTaskThreads, pthread_t threadIDs[]);double mcos(double val);double msin(double val);double mcosh(double val);double msinh(double val);double mexp(double val);double mlog(double val);double msqrt(double val);double mfabs(double val);double mfloor(double val);double mceil(double val);^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     ^Y Prev Page   M-\ First Line M-W WhereIs Next^X Exit^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  ^V Next Page   M-/ Last Line  M-] To Bracket[ line 2/285 (0%), col 1/21 (4%), char 19/7910 (0%) ]3118 (540421 (458[ line 5/285 (1%), col 1/1 (10079 [ line 6/285 (2%), col 1/70 (1801[ line 7/285 (2%), col 1/1 (100150/7910 (1%) ]883 (1%), char 1519324 (4234210/285 (3%), col 1/54 (1%), char 258/7910 (3%) ]183312242954[ line 13/285 (4%), col 1/1 (1004776 [ line 14/285 (4%), col 1/87 (18[ line 15/285 (5%), col 1/1 (1005657 [ line 16/285 (5%), col 1/48 (26715 (6614862 (5029941 (23120765 (165817239216 (681[ line 23/285 (8%), col 1/1 (1009710%) ]459 (1%), char 798536 (2857691 (100%), char 893/7910 (11%) ]729 (3%), char 894847 (2923[ line 29/285 (101 (100%), char 970/7910 (12%) ] [ line 30/285 (10%), col 1/84 (11[ line 31/285 (10%), col 1/25 (4%), char 10553218036 (31054314525 (45768276 (32075833397594046866// Functions to run on each elementconst unsigned int NFUNCTIONS = 10;double (*funcArray[10])(double) = {mcos, msin, mcosh, msinh, mexp, mlog, msqrt, mfabs, mfloor, mceil}; unsigned long NTIMES[10] = {40, 20, 10, 9, 6, 5, 4, 3, 2, 1};int main(int argc, char* argv[]){struct timespec t1, t2;double time12;// Get program argumentsif (argc != 3){fprintf(stderr, "Usage: %s ntasks nthreads\n", argv[0]);exit(EXIT_FAILURE);}unsigned int nTasks = atoi(argv[1]);unsigned int nThreads = atoi(argv[2]);if ((nTasks <= 0) || (nTasks > MAX_NTASKS_NTHREADS)){11 (100%), char 1312/7910 (16%) ]236 (2%), char 1313354974104 (0%), char 1385/7910 (17%) ]562 (1%), char 1489/7910 (18%) ]661 (100%), char 1551/7910 (19%) ]733 (3%), char 155282 (5085209732 (375023 (461219 (11282833 (330323 (456410 (10%), char 1672/7910 (21%) ]5973 (1%), char 1675636 (273472010 (10%), char 1756/7910 (22%) ]845 (2%), char 1759979760161 (1833110 (10%), char 1891/7910 (23%) ]fprintf(stderr, "ERROR: task count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if ((nThreads <= 0) || (nThreads > MAX_NTASKS_NTHREADS)){fprintf(stderr, "ERROR: thread count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if (nTasks > 1 && nThreads != nTasks){fprintf(stderr, "ERROR: thread count should be equal to task count for task count > 1\n");exit(EXIT_FAILURE);             }if (nTasks == 1 && nThreads == 1)printf("Running 1 monolitic task...\n");else if (nTasks == 1 && nThreads > 1)printf("Running 1 muktithreaded task...\n");elseprintf("Running %d monolitic tasks, each on a different thread...\n", nTasks);23 (43236 (2%), char 1983/7910 (25%) ]410 (10%), char 2005/7910 (25%) ]565 (1%), char 20086310 (10%), char 2066/7910 (26%) ]75 (9836 (2%), char 2160/7910 (27%) ]9410 (10%), char 2182/7910 (27%) ]7046 (2%), char 2185110 (10%), char 2224/7910 (28%) ]257 (7349 (2%), char 2320/7910 (29%) ]410 (10%), char 2344/7910 (29%) ]567 (5%), char 2347657 (150778730846 (2430961 (169180813 (7516195 (12221 (100%), char 2603/7910 (32%) ]unsigned int nTaskThreads = nThreads / nTasks; // Number of threads for each taskpthread_t threadIDs[nThreads]; // Thread IDs//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write here the appropiate instructions to start time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &tStart);// Start all the tasksfor (unsigned int taskIndex = 0; taskIndex < nTasks; taskIndex++){// Each task run nTaskThreads threads and saves their IDs into threads arrayif (task(taskIndex, nTaskThreads, threadIDs) < 0){fprintf(stderr, "Error running the task %d", taskIndex);exit(EXIT_FAILURE);}}// Wait for the threads of all the tasks to finish3990 (1%), char 260445387351 (100%), char 2733/7910 (34%) ]63091 (1%), char 2734732 (38185882 (143919191869/91 (99[ line 89/285 (31%), col 10/91 (10%), char 2920/7910 (36%) ]12123234345456567678778989/91 (209201301312423534645756867978/91 (308919302401412523634745856967/91 (407818929403509048 (830348155Modified7 (87096 (898rt);5 (917t);4 (936t);3 (9551);2/446/7906 [ line 91/285 (31%), col 1/1 (1009[ line 92/285 (32%), col 31/31 (100%), char 3063/7906 (38%) ]342/74 (56%), char 3098/7906 (39%) ]410/10 (100%), char 3133/7906 (39%) ]5342/93 (45%), char 3161666 (63240407418/18 (100%), char 3268/7906 (41%) ]842/81 (51%), char 3289944 (95342[ line 100518/18 (100%), char 3355/7906 (42%) ]10/108 [ line 102/285 (35%), col 9/9 (100%), char 33603642/59 (71%), char 3395/7906 (42%) ]for (unsigned int threadIndex = 0; threadIndex < nThreads; threadIndex++)pthread_join(threadIDs[threadIndex], NULL);// Free memmoryfor (unsigned taskIndex = 0; taskIndex < nTasks; taskIndex++)if (data[taskIndex] != NULL)free(data[taskIndex]);//////////////////////////////////////////////////////////////////////////////////// Finish measuring time// TODO: Write here the appropiate instructions to finish time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &tEnd);printf("Execution finished\n");//////////////////////////////////////////////////////////////////////////////////// Show the elapsed time// TODO: Write here the appropiate instructions to calculate the elapsed time//////////////////////////////////////////////////////////////////////////////////dElapsedTimeS = (tEnd.tv_sec - tStart.tv_sec);482 (54473560 (705154671/1 (100%), char 3534[ line 107/285 (37%), col 24/24 (100%), char 3551/7906 (44%) ] [ line 108/285 (37%), col 42/70 (68659845 (936426107 (896611/1 (100%), char 36722942/91 (46%), char 3707/7906 (46%) ][ line 113/285 (39%), col 33/33 (100827 [ line 114/285 (40%), col 42/83 (58178591 (46939646 (91977501/46 (896nd);5 (915d);4 (934);3 (9532);2/447/7904719/9 (100%), char 3981[ line 118/285 (41%), col 40/40 (100%), char 4014/7904 (50%) ] [ line 119/285 (41%), col 1/1 (100%), char 401520242/91 (46%), char 4050/7904 (51%) ][ line 121/285 (42%), col 33/33 (1001252 [ line 122/285 (42%), col 42/86 (48603391 (462393455 (73234dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;== -1   printf("Elapsed time    : %f s.\n", time12);return 0;}// Return a random number in the interval [min, max]double get_random(unsigned int min, unsigned int max){return min + (max - min) * ((double)rand()/(double)RAND_MAX);}// Function called by every threadvoid *thread_job(void *args){threadArgs_t *threadArgs = (threadArgs_t *)args;double *dta = threadArgs->data;unsigned int minIndex = threadArgs->minIndex;unsigned int maxIndex = threadArgs->maxIndex;unsigned int nTimesIndex = DNI % 10;573 (57715[ line 126/285 (44%), col 21/21 (100407 [ line 127/285 (44%), col 42/53 (7942689/9 (100%), char 4455[ line 129/285 (45%), col 18/18 (100%), char 4466/7904 (56%) ] [ line 128/285 (44%), col 9/9 (100%), char 4455742/53 (79%), char 4442/7904 (56%) ][ line 126/285 (44%), col 21/21 (100075 [ line 125/285 (43%), col 42/73 (57371455 (76234573 (57715160046939388277066/73 (495574463352231120015929/73 (3988877666555444233122011/73 (2800749196884747366155044/73 (19337226115003399/73 (12%), char 4338/dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;== -110/73 (13%), char 4339/7905 (54%) ]//dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;== -11540/7906455 (202920/55 (1819/55 (16%), char 429045342 (173120 (18149088997 (198675 (20645342 (213t = (tEnd.tv_sec - tStart.tv_sec);10/43 (23%), char 4291/7894 (54%) ]i = (tEnd.tv_sec - tStart.tv_sec);1/44 (252/7895e = (tEnd.tv_sec - tStart.tv_sec);2/45 (263/78961/44 (252/7895m = (tEnd.tv_sec - tStart.tv_sec);2/45 (263/7896e = (tEnd.tv_sec - tStart.tv_sec);3/46 (284/78971 = (tEnd.tv_sec - tStart.tv_sec);4/47 (295/78982 = (tEnd.tv_sec - tStart.tv_sec);5/48 (316/78996377588799930020/48 (4117 (4286 (4375 (4462.tv_sec - tStart.tv_sec);1/46 (452/78972733/46 (5044255466677888/46 (609931030511722935 (7164 (7253 (7442 (7631 (7821.tv_sec);3/424/7893Save modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                                                                                  Y Yes N No   ^C CancelFile Name to Write: program.c                               ^G Get HelpM-D DOS FormatM-A AppendM-B Backup File^C Cancel            M-M Mac FormatM-P Prepend^T To Files [ Wrote 284 lines ]        student@2ac:~$ sudo nano -c program.cgcc program.c -o program -lm -lpthread
student@2ac:~$ ls
2ac-pl4-uo281827  cpu.txt  examen1.tar.gz  program  program.c  results.xls
student@2ac:~$ ./ rpprogram 1 1
-bash: ./: Is a directory
student@2ac:~$ ./program 1.1
Usage: ./program ntasks nthreads
student@2ac:~$ program 1 1
program: command not found
student@2ac:~$ ./program 1 1./program 1.11 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 6.000000 s.
student@2ac:~$ ./program 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 7.000000 s.
student@2ac:~$ ./program 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 7.000000 s.
student@2ac:~$ ./program 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 6.000000 s.
student@2ac:~$ ./program 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 7.000000 s.
student@2ac:~$ ./program 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 7.000000 s.
student@2ac:~$ ./program 1 17 7
Running 7 monolitic tasks, each on a different thread...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Running thread 1 of task 0; minIndex = 0, maxIndex = 55439
Running thread 2 of task 0; minIndex = 0, maxIndex = 55439
Running thread 3 of task 0; minIndex = 0, maxIndex = 55439
Running thread 4 of task 0; minIndex = 0, maxIndex = 55439
Running thread 5 of task 0; minIndex = 0, maxIndex = 55439
Running thread 6 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 11.000000 s.
student@2ac:~$ ./program 7 7
Running 7 monolitic tasks, each on a different thread...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Running thread 1 of task 0; minIndex = 0, maxIndex = 55439
Running thread 2 of task 0; minIndex = 0, maxIndex = 55439
Running thread 3 of task 0; minIndex = 0, maxIndex = 55439
Running thread 4 of task 0; minIndex = 0, maxIndex = 55439
Running thread 5 of task 0; minIndex = 0, maxIndex = 55439
Running thread 6 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 11.000000 s.
student@2ac:~$ ./program 7 7
Running 7 monolitic tasks, each on a different thread...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Running thread 1 of task 0; minIndex = 0, maxIndex = 55439
Running thread 2 of task 0; minIndex = 0, maxIndex = 55439
Running thread 3 of task 0; minIndex = 0, maxIndex = 55439
Running thread 4 of task 0; minIndex = 0, maxIndex = 55439
Running thread 5 of task 0; minIndex = 0, maxIndex = 55439
Running thread 6 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 12.000000 s.
student@2ac:~$ ./program 7 7
Running 7 monolitic tasks, each on a different thread...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Running thread 1 of task 0; minIndex = 0, maxIndex = 55439
Running thread 2 of task 0; minIndex = 0, maxIndex = 55439
Running thread 3 of task 0; minIndex = 0, maxIndex = 55439
Running thread 4 of task 0; minIndex = 0, maxIndex = 55439
Running thread 5 of task 0; minIndex = 0, maxIndex = 55439
Running thread 6 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 11.000000 s.
student@2ac:~$ ./program 7 71 1./7 7sudo nano -c program.cmm.c
[ Reading File ][ Read 284 lines ]  GNU nano 2.5.3                                  File: program.c                                                                            #include <stdio.h>#include <stdlib.h> #include <math.h>#include <pthread.h>#define MAX_NTASKS_NTHREADS 22 // Maximum number of tasks and threads//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write down your DNI without the final letter//////////////////////////////////////////////////////////////////////////////////const unsigned int DNI = 53777253; // Example: const unsigned int DNI = 12345678 const unsigned long NELEMENTS = 55440; // Number of elements to be processed by a task// Structure with the parameters of each threadtypedef struct{double *data; // Array with dataunsigned int minIndex; // Minimum array index to processunsigned int maxIndex; // Maximum array index to process} threadArgs_t;// Data to be proceeeed by the tasks. One pointer per taskdouble *data[MAX_NTASKS_NTHREADS] ;// Thread function argumentsthreadArgs_t threadArgs[MAX_NTASKS_NTHREADS]; int task(unsigned int taskIndex, unsigned int nTaskThreads, pthread_t threadIDs[]);double mcos(double val);double msin(double val);double mcosh(double val);double msinh(double val);double mexp(double val);double mlog(double val);double msqrt(double val);double mfabs(double val);double mfloor(double val);double mceil(double val);^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     ^Y Prev Page   M-\ First Line M-W WhereIs Next^X Exit^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  ^V Next Page   M-/ Last Line  M-] To Bracket[ line 2/285 (0%), col 1/21 (4%), char 19/7893 (0%) ]3118 (540421 (458[ line 5/285 (1%), col 1/1 (100791 [ line 6/285 (2%), col 1/70 (180[ line 7/285 (2%), col 1/1 (100150/7893 (1%) ]883 (1%), char 1519324 (4234210/285 (3%), col 1/54 (1%), char 258/7893 (3%) ]183312242955[ line 13/285 (4%), col 1/1 (1004776 [ line 14/285 (4%), col 1/87 (18[ line 15/285 (5%), col 1/1 (1005657 [ line 16/285 (5%), col 1/48 (26715 (6614862 (5029941 (23120765 (165817239216 (681[ line 23/285 (8%), col 1/1 (1009710%) ]459 (1%), char 798536 (2857691 (100%), char 893/7893 (11%) ]729 (3%), char 894847 (2923[ line 29/285 (101 (100%), char 970/7893 (12%) ] [ line 30/285 (10%), col 1/84 (11[ line 31/285 (10%), col 1/25 (4%), char 10553218036 (31054314525 (45768276 (32075833397594046866// Functions to run on each elementconst unsigned int NFUNCTIONS = 10;double (*funcArray[10])(double) = {mcos, msin, mcosh, msinh, mexp, mlog, msqrt, mfabs, mfloor, mceil}; unsigned long NTIMES[10] = {40, 20, 10, 9, 6, 5, 4, 3, 2, 1};int main(int argc, char* argv[]){struct timespec t1, t2;double time12;// Get program argumentsif (argc != 3){fprintf(stderr, "Usage: %s ntasks nthreads\n", argv[0]);exit(EXIT_FAILURE);}unsigned int nTasks = atoi(argv[1]);unsigned int nThreads = atoi(argv[2]);if ((nTasks <= 0) || (nTasks > MAX_NTASKS_NTHREADS)){11 (100%), char 1312/7893 (16%) ]236 (2%), char 1313354974104 (0%), char 1385/7893 (17%) ]562 (1%), char 1489/7893 (18%) ]661 (100%), char 1551/7893 (19%) ]733 (3%), char 155282 (5085209732 (375023 (461219 (11282833 (330323 (456410 (10%), char 1672/7893 (21%) ]5973 (1%), char 1675636 (273472010 (10%), char 1756/7893 (22%) ]845 (2%), char 1759979760161 (1833110 (10%), char 1891/7893 (23%) ]fprintf(stderr, "ERROR: task count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if ((nThreads <= 0) || (nThreads > MAX_NTASKS_NTHREADS)){fprintf(stderr, "ERROR: thread count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if (nTasks > 1 && nThreads != nTasks){fprintf(stderr, "ERROR: thread count should be equal to task count for task count > 1\n");exit(EXIT_FAILURE);             }if (nTasks == 1 && nThreads == 1)printf("Running 1 monolitic task...\n");else if (nTasks == 1 && nThreads > 1)printf("Running 1 muktithreaded task...\n");elseprintf("Running %d monolitic tasks, each on a different thread...\n", nTasks);23 (43236 (2%), char 1983/7893 (25%) ]410 (10%), char 2005/7893 (25%) ]565 (1%), char 20086310 (10%), char 2066/7893 (26%) ]75 (9836 (2%), char 2160/7893 (27%) ]9410 (10%), char 2182/7893 (27%) ]7046 (2%), char 2185110 (10%), char 2224/7893 (28%) ]257 (7349 (2%), char 2320/7893 (29%) ]410 (10%), char 2344/7893 (29%) ]567 (5%), char 2347657 (150778730846 (2430961 (169180813 (7516195 (12221 (100%), char 2603/7893 (32%) ]unsigned int nTaskThreads = nThreads / nTasks; // Number of threads for each taskpthread_t threadIDs[nThreads]; // Thread IDs//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write here the appropiate instructions to start time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &t1);// Start all the tasksfor (unsigned int taskIndex = 0; taskIndex < nTasks; taskIndex++){// Each task run nTaskThreads threads and saves their IDs into threads arrayif (task(taskIndex, nTaskThreads, threadIDs) < 0){fprintf(stderr, "Error running the task %d", taskIndex);exit(EXIT_FAILURE);}}// Wait for the threads of all the tasks to finish3990 (1%), char 260445387451 (100%), char 2733/7893 (34%) ]63091 (1%), char 2734732 (38185882 (143691919189044 (23002811 (100%), char 3039/7893 (38%) ]2231 (3%), char 3040374 (164410 (10%), char 3131/7893 (39%) ]5393 (1%), char 3134666213407418 (5651881 (19944 (2322100/285 (35%), col 1/18 (5%), char 3352/7893 (42%) ][ line 101/285 (35%), col 1/10 (106 [ line 102/285 (35%), col 1/9 (1193659 (61for (unsigned int threadIndex = 0; threadIndex < nThreads; threadIndex++)pthread_join(threadIDs[threadIndex], NULL);// Free memmoryfor (unsigned taskIndex = 0; taskIndex < nTasks; taskIndex++)if (data[taskIndex] != NULL)free(data[taskIndex]);//////////////////////////////////////////////////////////////////////////////////// Finish measuring time// TODO: Write here the appropiate instructions to finish time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &t2);printf("Execution finished\n");//////////////////////////////////////////////////////////////////////////////////// Show the elapsed time// TODO: Write here the appropiate instructions to calculate the elapsed time//////////////////////////////////////////////////////////////////////////////////time12 = (t2.tv_sec - t1.tv_sec);4824133560884[ line 106/285 (37%), col 1/1 (100534 [ line 107/285 (37%), col 1/24 (45870 (15259845 (2615107466[ line 111/285 (38%), col 1/1 (10072 [ line 112/285 (39%), col 1/91 (13333 (3757744083 (1835918598644 (29439719 (118050840 (22[ line 119/285 (41%), col 1/1 (1004015 [ line 120/285 (42%), col 1/91 (16133 (31001286 (126233912053442 (2894//dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;== -1 printf("Elapsed time    : %f s.\n", time12);return 0;}// Return a random number in the interval [min, max]double get_random(unsigned int min, unsigned int max){return min + (max - min) * ((double)rand()/(double)RAND_MAX);}// Function called by every threadvoid *thread_job(void *args){threadArgs_t *threadArgs = (threadArgs_t *)args;double *dta = threadArgs->data;unsigned int minIndex = threadArgs->minIndex;unsigned int maxIndex = threadArgs->maxIndex;unsigned int nTimesIndex = DNI % 10;573 (13246421 (4905753 (1789 (144369518 (55302 (5056[ line 131/285 (45%), col 1/1 (108 [ line 132/285 (46%), col 1/53 (19345127472 (5066570 (1862 (506318[ line 137/285 (48%), col 1/1 (103 [ line 138/285 (48%), col 1/35 (24929 (3699409 (5098157 (1700240 (256035054 (18348301545 (277for (unsigned int funcIndex = 0; funcIndex < NFUNCTIONS; funcIndex++){for (unsigned int i = 0; i < NTIMES[nTimesIndex]; i++)for (unsigned int elementIndex = minIndex; elementIndex < maxIndex; elementIndex++){funcArray[funcIndex](dta[elementIndex]);}nTimesIndex++;if (nTimesIndex == NFUNCTIONS)nTimesIndex = 0;}       return NULL;}// Run task of index taskIndex using nTaskThreads threads. Thread IDs are saved in threadIDsint task(unsigned int taskIndex, unsigned int nTaskThreads, pthread_t threadIDs[]){static unsigned int seed = 0; // Random seed619 (119152778 (7[ line 148/285 (51%), col 1/10 (10883 [ line 149/285 (52%), col 1/71 (191[ line 150/285 (52%), col 1/108 (05048 [ line 151/285 (52%), col 1/26 (313552373 (140326 (385443190547 (2207614067517 (5689 (114921 (46606 (5080[ line 161/285 (56%), col 1/1 (102 [ line 162/285 (56%), col 1/93 (1337837682692836[ line 161/285 (56%), col 1/1 (1002 [ line 160/285 (56%), col 1/2 (505951 (46689 (114717 (506441 (2457075431 (3190332685273 (1401226 (335[ line 150/285 (52%), col 1/108 (00483 [ line 149/285 (52%), col 1/71 (14991[ line 148/285 (51%), col 1/10 (1088 [ line 147/285 (51%), col 1/78 (117269 (155045 (28771454 (1303783024940 (250157 (105902 (506983989 (369835 (2348[ line 137/285 (48%), col 1/1 (1003 [ line 136/285 (47%), col 1/2 (51570 (1568742 (5063654 (112234596[ line 131/285 (45%), col 1/1 (1008 [ line 130/285 (45%), col 1/2 (562918 (545849 (113753 (3975// Free memmoryfor (unsigned taskIndex = 0; taskIndex < nTasks; taskIndex++)if (data[taskIndex] != NULL)free(data[taskIndex]);//////////////////////////////////////////////////////////////////////////////////// Finish measuring time// TODO: Write here the appropiate instructions to finish time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &t2);printf("Execution finished\n");//////////////////////////////////////////////////////////////////////////////////// Show the elapsed time// TODO: Write here the appropiate instructions to calculate the elapsed time//////////////////////////////////////////////////////////////////////////////////time12 = (t2.tv_sec - t1.tv_sec);//dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;== -1 621 (405373 (1244442 (2289573 (13246421 (49055373 (1244[ line 125/285 (43%), col 9/73 (12510/73 (13%), char 4326/7893 (54%) ]9/73 (12%), char 4325Modified/dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;== -1 2dElapsedTimeS += (tEnd.tv_nsec - tStart.tv_nsec) / 1e+9;== -1 1442 (21290 [ line 123/285 (43%), col 9/91 (9063[ line 124/285 (43%), col 9/42 (21904573 (1232510/73 (13%), char 4326/7891 (54%) ]15726837949305/73 (20161273384496520761872/73 (30831942405415652763884995884nd.tv_nsec - tStart.tv_nsec) / 1e+9;== -1 0d.tv_nsec - tStart.tv_nsec) / 1e+9;== -1 89.tv_nsec - tStart.tv_nsec) / 1e+9;== -1 8tv_nsec - tStart.tv_nsec) / 1e+9;== -1 72tv_nsec - tStart.tv_nsec) / 1e+9;== -1995/7888.tv_nsec - tStart.tv_nsec) / 1e+9;== -130/73 (416/788912723835946505716927/73 (5038249354046167tart.tv_nsec) / 1e+9;== -1 8art.tv_nsec) / 1e+9;== -1 7rt.tv_nsec) / 1e+9;== -1 6t.tv_nsec) / 1e+9;== -1 65 (635.tv_nsec) / 1e+9;== -1 41.tv_nsec) / 1e+9;== -1248/788536947605916/65 (70272383495550661872/65 (80831943705416627738949/65 (905= -1 4 -1 3-1 21 1 0Save modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                                                                                  Y Yes N No   ^C CancelFile Name to Write: program.c                               ^G Get HelpM-D DOS FormatM-A AppendM-B Backup File^C Cancel            M-M Mac FormatM-P Prepend^T To Files [ Wrote 284 lines ]        student@2ac:~$ sudo naog ccc progfram.c -o program -lm -lpthread
program.c: In function main:
program.c:125:2: error: dElapsedTimeS undeclared (first use in this function)
  dElapsedTimeS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 
  ^
program.c:125:2: note: each undeclared identifier is reported only once for each function it appears in
student@2ac:~$ sudo gcc program.c -o program -lm -lpthreadnano -c program.c
[ Reading File ][ Read 284 lines ]  GNU nano 2.5.3                                  File: program.c                                                                            #include <stdio.h>#include <stdlib.h> #include <math.h>#include <pthread.h>#define MAX_NTASKS_NTHREADS 22 // Maximum number of tasks and threads//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write down your DNI without the final letter//////////////////////////////////////////////////////////////////////////////////const unsigned int DNI = 53777253; // Example: const unsigned int DNI = 12345678 const unsigned long NELEMENTS = 55440; // Number of elements to be processed by a task// Structure with the parameters of each threadtypedef struct{double *data; // Array with dataunsigned int minIndex; // Minimum array index to processunsigned int maxIndex; // Maximum array index to process} threadArgs_t;// Data to be proceeeed by the tasks. One pointer per taskdouble *data[MAX_NTASKS_NTHREADS] ;// Thread function argumentsthreadArgs_t threadArgs[MAX_NTASKS_NTHREADS]; int task(unsigned int taskIndex, unsigned int nTaskThreads, pthread_t threadIDs[]);double mcos(double val);double msin(double val);double mcosh(double val);double msinh(double val);double mexp(double val);double mlog(double val);double msqrt(double val);double mfabs(double val);double mfloor(double val);double mceil(double val);^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     ^Y Prev Page   M-\ First Line M-W WhereIs Next^X Exit^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  ^V Next Page   M-/ Last Line  M-] To Bracket[ line 2/285 (0%), col 1/21 (4%), char 19/7880 (0%) ]3118 (540421 (458[ line 5/285 (1%), col 1/1 (100791 [ line 6/285 (2%), col 1/70 (180[ line 7/285 (2%), col 1/1 (100150/7880 (1%) ]883 (1%), char 1519324 (4234210/285 (3%), col 1/54 (1%), char 258/7880 (3%) ]183312242955[ line 13/285 (4%), col 1/1 (1004776 [ line 14/285 (4%), col 1/87 (18[ line 15/285 (5%), col 1/1 (1005657 [ line 16/285 (5%), col 1/48 (26715 (6614862 (5029941 (231820765 (16517239216 (681[ line 23/285 (8%), col 1/1 (1009710%) ]459 (1%), char 798536 (2857691 (100%), char 893/7880 (11%) ]729 (3%), char 894847 (2923[ line 29/285 (101 (100%), char 970/7880 (12%) ] [ line 30/285 (10%), col 1/84 (11[ line 31/285 (10%), col 1/25 (4%), char 10553218036 (31054431525 (457682576 (3207833397594046866// Functions to run on each elementconst unsigned int NFUNCTIONS = 10;double (*funcArray[10])(double) = {mcos, msin, mcosh, msinh, mexp, mlog, msqrt, mfabs, mfloor, mceil}; unsigned long NTIMES[10] = {40, 20, 10, 9, 6, 5, 4, 3, 2, 1};int main(int argc, char* argv[]){struct timespec t1, t2;double time12;// Get program argumentsif (argc != 3){fprintf(stderr, "Usage: %s ntasks nthreads\n", argv[0]);exit(EXIT_FAILURE);}unsigned int nTasks = atoi(argv[1]);unsigned int nThreads = atoi(argv[2]);if ((nTasks <= 0) || (nTasks > MAX_NTASKS_NTHREADS)){11 (100%), char 1312/7880 (16%) ]236 (2%), char 1313354974104 (0%), char 1385/7880 (17%) ]562 (1%), char 1489/7880 (18%) ]661 (100%), char 1551/7880 (19%) ]733 (3%), char 155282 (5085209732 (375023 (461219 (11282833 (330323 (4561410 (10%), char 1672/7880 (21%) ]5973 (1%), char 1675636 (2734272010 (10%), char 1756/7880 (22%) ]845 (2%), char 1759979760161 (1833110 (10%), char 1891/7880 (23%) ]fprintf(stderr, "ERROR: task count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if ((nThreads <= 0) || (nThreads > MAX_NTASKS_NTHREADS)){fprintf(stderr, "ERROR: thread count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if (nTasks > 1 && nThreads != nTasks){fprintf(stderr, "ERROR: thread count should be equal to task count for task count > 1\n");exit(EXIT_FAILURE);             }if (nTasks == 1 && nThreads == 1)printf("Running 1 monolitic task...\n");else if (nTasks == 1 && nThreads > 1)printf("Running 1 muktithreaded task...\n");elseprintf("Running %d monolitic tasks, each on a different thread...\n", nTasks);23 (443236 (2%), char 1983/7880 (25%) ]410 (10%), char 2005/7880 (25%) ]565 (1%), char 20086310 (10%), char 2066/7880 (26%) ]75 (9836 (2%), char 2160/7880 (27%) ]9410 (10%), char 2182/7880 (27%) ]7046 (2%), char 2185110 (10%), char 2224/7880 (28%) ]257 (7349 (2%), char 2320/7880 (29%) ]410 (10%), char 2344/7880 (29%) ]567 (5%), char 2347657 (150778730846 (2430961 (169180813 (7516195 (122221 (100%), char 2603/7880 (33%) ]unsigned int nTaskThreads = nThreads / nTasks; // Number of threads for each taskpthread_t threadIDs[nThreads]; // Thread IDs//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write here the appropiate instructions to start time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &t1);// Start all the tasksfor (unsigned int taskIndex = 0; taskIndex < nTasks; taskIndex++){// Each task run nTaskThreads threads and saves their IDs into threads arrayif (task(taskIndex, nTaskThreads, threadIDs) < 0){fprintf(stderr, "Error running the task %d", taskIndex);exit(EXIT_FAILURE);}}// Wait for the threads of all the tasks to finish3990 (1%), char 260445387451 (100%), char 2733/7880 (34%) ]63091 (1%), char 2734732 (38185882 (1436919191879044 (23002811 (100%), char 3039/7880 (38%) ]2231 (3%), char 3040374 (164410 (10%), char 3131/7880 (39%) ]5393 (1%), char 3134666213407418 (5651881 (19944 (2322100/285 (35%), col 1/18 (5%), char 3352/7880 (42%) ][ line 101/285 (35%), col 1/10 (106 [ line 102/285 (35%), col 1/9 (1193659 (61for (unsigned int threadIndex = 0; threadIndex < nThreads; threadIndex++)pthread_join(threadIDs[threadIndex], NULL);// Free memmoryfor (unsigned taskIndex = 0; taskIndex < nTasks; taskIndex++)if (data[taskIndex] != NULL)free(data[taskIndex]);//////////////////////////////////////////////////////////////////////////////////// Finish measuring time// TODO: Write here the appropiate instructions to finish time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &t2);printf("Execution finished\n");//////////////////////////////////////////////////////////////////////////////////// Show the elapsed time// TODO: Write here the appropiate instructions to calculate the elapsed time//////////////////////////////////////////////////////////////////////////////////time12 = (t2.tv_sec - t1.tv_sec);4824133560884[ line 106/285 (37%), col 1/1 (100534 [ line 107/285 (37%), col 1/24 (45870 (15259845 (2615107466[ line 111/285 (38%), col 1/1 (10072 [ line 112/285 (39%), col 1/91 (13333 (3757744083 (1838591859644 (294350719 (1180840 (22[ line 119/285 (41%), col 1/1 (1004015 [ line 120/285 (42%), col 1/91 (16133 (31002286 (12633912053442 (2894dElapsedTimeS += (t2.tv_nsec - t1.tv_nsec) / 1e+9;      printf("Elapsed time    : %f s.\n", time12);return 0;}// Return a random number in the interval [min, max]double get_random(unsigned int min, unsigned int max){return min + (max - min) * ((double)rand()/(double)RAND_MAX);}// Function called by every threadvoid *thread_job(void *args){threadArgs_t *threadArgs = (threadArgs_t *)args;double *dta = threadArgs->data;unsigned int minIndex = threadArgs->minIndex;unsigned int maxIndex = threadArgs->maxIndex;unsigned int nTimesIndex = DNI % 10;565 (13246421 (4775753 (18489 (143069518 (52302 (5043[ line 131/285 (45%), col 1/1 (105 [ line 132/285 (46%), col 1/53 (1634997472 (50553570 (1542 (5033654 (149923466[ line 131/285 (45%), col 1/1 (1005 [ line 130/285 (45%), col 1/2 (532918 (532849 (110753 (3845621 (477[ line 126/285 (44%), col 9/21 (42817/21 (80%), char 4379/7880 (55%) ]5365 (2633464253141030292/65 (1881670569/65 (13%), char 4325ModifiedElapsedTimeS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 79lapsedTimeS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 8apsedTimeS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 57 (157psedTimeS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 6sedTimeS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 5edTimeS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 4dTimeS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 3TimeS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 2imeS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 1meS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 0eS += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 49 (1869S += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 8 += (t2.tv_nsec - t1.tv_nsec) / 1e+9; 7t += (t2.tv_nsec - t1.tv_nsec) / 1e+9;10/49 (20%), char 4326/7868 (54%) ]i += (t2.tv_nsec - t1.tv_nsec) / 1e+9;127/7869m += (t2.tv_nsec - t1.tv_nsec) / 1e+9;        2/57 (218/7870e += (t2.tv_nsec - t1.tv_nsec) / 1e+9;329/78711 += (t2.tv_nsec - t1.tv_nsec) / 1e+9;4430/7872 (552 += (t2.tv_nsec - t1.tv_nsec) / 1e+9;561/7873Save modified buffer (ANSWERING "No" WILL DESTROY CHANGES) ?                                                                                  Y Yes N No   ^C CancelFile Name to Write: program.c                               ^G Get HelpM-D DOS FormatM-A AppendM-B Backup File^C Cancel            M-M Mac FormatM-P Prepend^T To Files [ Wrote 284 lines ]        student@2ac:~$ sudo nano -c program.cgcc program.c -o program -lm -lpthread
student@2ac:~$ sudo gcc program.c -o program -lm -lpthread./program 11  1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 6.298822 s.
student@2ac:~$ ./program 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 6.532460 s.
student@2ac:~$ ./program 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 6.434968 s.
student@2ac:~$ ./program 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 6.420789 s.
student@2ac:~$ ./program 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 6.402537 s.
student@2ac:~$ ./ program 7 7 program 7 7
Running 7 monolitic tasks, each on a different thread...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Running thread 1 of task 0; minIndex = 0, maxIndex = 55439
Running thread 2 of task 0; minIndex = 0, maxIndex = 55439
Running thread 3 of task 0; minIndex = 0, maxIndex = 55439
Running thread 4 of task 0; minIndex = 0, maxIndex = 55439
Running thread 5 of task 0; minIndex = 0, maxIndex = 55439
Running thread 6 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 12.262641 s.
student@2ac:~$ ./program 7 7
Running 7 monolitic tasks, each on a different thread...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Running thread 1 of task 0; minIndex = 0, maxIndex = 55439
Running thread 2 of task 0; minIndex = 0, maxIndex = 55439
Running thread 3 of task 0; minIndex = 0, maxIndex = 55439
Running thread 4 of task 0; minIndex = 0, maxIndex = 55439
Running thread 5 of task 0; minIndex = 0, maxIndex = 55439
Running thread 6 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 11.926166 s.
student@2ac:~$ ./program 7 7
Running 7 monolitic tasks, each on a different thread...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Running thread 1 of task 0; minIndex = 0, maxIndex = 55439
Running thread 2 of task 0; minIndex = 0, maxIndex = 55439
Running thread 3 of task 0; minIndex = 0, maxIndex = 55439
Running thread 4 of task 0; minIndex = 0, maxIndex = 55439
Running thread 5 of task 0; minIndex = 0, maxIndex = 55439
Running thread 6 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 11.872817 s.
student@2ac:~$ ./program 7 7
Running 7 monolitic tasks, each on a different thread...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Running thread 1 of task 0; minIndex = 0, maxIndex = 55439
Running thread 2 of task 0; minIndex = 0, maxIndex = 55439
Running thread 3 of task 0; minIndex = 0, maxIndex = 55439
Running thread 4 of task 0; minIndex = 0, maxIndex = 55439
Running thread 5 of task 0; minIndex = 0, maxIndex = 55439
Running thread 6 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 12.027066 s.
student@2ac:~$ ./program 7 7
Running 7 monolitic tasks, each on a different thread...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Running thread 1 of task 0; minIndex = 0, maxIndex = 55439
Running thread 2 of task 0; minIndex = 0, maxIndex = 55439
Running thread 3 of task 0; minIndex = 0, maxIndex = 55439
Running thread 4 of task 0; minIndex = 0, maxIndex = 55439
Running thread 5 of task 0; minIndex = 0, maxIndex = 55439
Running thread 6 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 11.933043 s.
student@2ac:~$ sudo gcc -O23 program.c -o program2 -lm -lpthread
student@2ac:~$ ./program2 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 2.863299 s.
student@2ac:~$ ./program2 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 2.917135 s.
student@2ac:~$ ./program2 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 2.908386 s.
student@2ac:~$ ./program2 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 2.922605 s.
student@2ac:~$ ./program2 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 2.884119 s.
student@2ac:~$ sudo gcc pprograma.c.c -opg -o program3 -l m -lpthreaeddd
student@2ac:~$ sudo ./program3 1 1
Running 1 monolitic task...
Running thread 0 of task 0; minIndex = 0, maxIndex = 55439
Execution finished
Elapsed time    : 6.339020 s.
student@2ac:~$ sudo gprof p./program3 > inforemme.txt
student@2ac:~$ sudo nano -c oinforme.txt 
[ Reading File ][ Read 204 lines ]  GNU nano 2.5.3                                  File: informe.txt                                                                          Flat profile:Each sample counts as 0.01 seconds.%   cumulative   selfself     total time   seconds   seconds    calls  ns/call  ns/call  name 46.880.30     0.30  2217560   135.28   135.28  mfabs 23.440.45     0.15  1108780   135.28   135.28  mfloor9.380.51     0.06   498951   120.25   120.25  mcos6.250.55     0.04   554390    72.15    72.15  mceil3.120.57     0.02   110878   180.38   180.38  mlog3.120.59     0.02thread_job1.560.60     0.01   332634    30.06    30.06  msin1.560.61     0.01   277195    36.08    36.08  mcosh1.560.62     0.01   221756    45.09    45.09  msinh1.560.63     0.01   166317    60.13    60.13  mexp1.560.64     0.01    55439   180.38   180.38  msqrt0.000.64     0.00    55440     0.00     0.00  get_random0.000.64     0.001     0.00     0.00  task %the percentage of the total running time of thetimeprogram used by this function.cumulative a running sum of the number of seconds accounted seconds   for by this function and those listed above it. selfthe number of seconds accounted for by thisseconds    function alone.  This is the major sort for thislisting.callsthe number of times this function was invoked, ifthis function is profiled, else blank. selfthe average number of milliseconds spent in thisms/call    function per call, if this function is profiled,else blank. total     the average number of milliseconds spent in thisms/call    function and its descendents per call, if thisfunction is profiled, else blank.^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     ^Y Prev Page   M-\ First Line M-W WhereIs Next^X Exit^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  ^V Next Page   M-/ Last Line  M-] To Bracket[ line 2/205 (0%), col 1/1 (100%), char 14/9207 (0%) ] [ line 3/205 (1%), col 1/36 (25463 (151[ line 5/205 (2%), col 1/63 (1%), char 11416077731232859983946035710/205 (4%), col 1/59 (1%), char 417/9207 (4%) ]156576525954136606006467575972660798785839859904[ line 19/205 (9%), col 1/1 (1006310%) ]2059 (1%), char 964[ line 21/205 (1042 (21023/9207 (11%) ]21 (100%), char 1065/9207 (11%) ]3160 (1%), char 1066459122521 (100%), char 1185/9207 (12%) ]655 (1%), char 118673602413820 (5304941 (100%), char 1321/9207 (14%) ]3061 (1%), char 13221550 (283521 (100%), char 1433/9207 (15%) ]3660 (1%), char 14344965723 (45561 (100%), char 1570/9207 (17%) ]7860 (1%), char 1571858639945 (2898401 (100%), char 1727/9207 (18%) ]namethe name of the function.  This is the minor sortfor this listing. The index shows the location ofthe function in the gprof listing. If the index isin parenthesis it shows where it would appear inthe gprof listing if it were to be printed.^LCopyright (C) 2012-2015 Free Software Foundation, Inc.Copying and distribution of this file, with or without modification,are permitted in any medium without royalty provided the copyrightnotice and this notice are preserved.^LCall graph (explanation follows)granularity: each sample hit covers 4 byte(s) for 1.56% of 0.64 secondsindex % time    self  children    called     name<spontaneous>[1]    100.0    0.02    0.62thread_job [1]0.30    0.00 2217560/2217560     mfabs [2]12061 (1%), char 172828993285020410905555581623 (332006755 (18831 (100%), char 2063/9207 (22%) ]969 (1%), char 206450471333138 (220025 (33384354 (140461 (100%), char 2280/9207 (24%) ]516772 (1%), char 228271 (100%), char 2354/9207 (25%) ]8850 (2%), char 2355963 (14066090681595270.15    0.00 1108780/1108780     mfloor [3]0.06    0.00  498951/498951mcos [4]0.04    0.00  554390/554390mceil [5]0.02    0.00  110878/110878mlog [6]0.01    0.00  332634/332634msin [7]0.01    0.00  277195/277195mcosh [8]0.01    0.00  221756/221756msinh [9]0.01    0.00  166317/166317mexp [10]0.01    0.00   55439/55439msqrt [11]-----------------------------------------------0.30    0.00 2217560/2217560     thread_job [1][2]     46.9    0.30    0.00 2217560mfabs [2]-----------------------------------------------0.15    0.00 1108780/1108780     thread_job [1][3]     23.4    0.15    0.00 1108780mfloor [3]-----------------------------------------------0.06    0.00  498951/498951thread_job [1][4]9.4    0.06    0.00  498951mcos [4]-----------------------------------------------0.04    0.00  554390/554390thread_job [1][5]6.2    0.04    0.00  554390mceil [5]2306087835864419705930864782605812959287060466598305850 (2355771 (100%), char 2354/9207 (25%) ]672 (1%), char 2282/9207 (24%) ]561 (100%), char 2281/9207 (24%) ]403554 (1%), char 22423 (3338148 (2003067 (11334939064281 (100%), char 2063/9207 (22%) ]7255 (1%), char 2008/9207 (21%) ]63 (3365155 (11958460050302850cumulative a running sum of the number of seconds accounted seconds   for by this function and those listed above it. selfthe number of seconds accounted for by thisseconds    function alone.  This is the major sort for thislisting.callsthe number of times this function was invoked, ifthis function is profiled, else blank. selfthe average number of milliseconds spent in thisms/call    function per call, if this function is profiled,else blank. total     the average number of milliseconds spent in thisms/call    function and its descendents per call, if thisfunction is profiled, else blank.namethe name of the function.  This is the minor sortfor this listing. The index shows the location of217891912880191 (100%), char 1727/9207 (18%) ]3945 (2%), char 16898858 (131776057671 (100%), char 1570/9207 (17%) ]523 (4%), char 1554/9207 (16%) ]4660 (149335251 (100%), char 1433/9207 (15%) ]150 (2%), char 1380461 (1224291 (100%), char 1321/9207 (14%) ]8320 (5%), char 130760 (12436255186251 (100%), char 1185/9207 (12%) ]4159 (1%), char 1126360061201 (100%), char 1065/9207 (11%) ]Flat profile:Each sample counts as 0.01 seconds.%   cumulative   selfself     total time   seconds   seconds    calls  ns/call  ns/call  name 46.880.30     0.30  2217560   135.28   135.28  mfabs 23.440.45     0.15  1108780   135.28   135.28  mfloor9.380.51     0.06   498951   120.25   120.25  mcos6.250.55     0.04   554390    72.15    72.15  mceil3.120.57     0.02   110878   180.38   180.38  mlog3.120.59     0.02thread_job1.560.60     0.01   332634    30.06    30.06  msin1.560.61     0.01   277195    36.08    36.08  mcosh1.560.62     0.01   221756    45.09    45.09  msinh1.560.63     0.01   166317    60.13    60.13  mexp1.560.64     0.01    55439   180.38   180.38  msqrt0.000.64     0.00    55440     0.00     0.00  get_random0.000.64     0.001     0.00     0.00  task %the percentage of the total running time of thetimeprogram used by this function.142 (2%), char 1023 [ line 20/205 (959 (1964/9207 (10%) ]191 (100%), char 963/9207 (10%) ] [ line 18/205 (8%), col 1/59 (1049%) ]7658396707785592074660663062559541516547604591749/205 (4%), col 1/60 (1%), char 357/9207 (3%) ]83592987613726201715314 [ line 4/205 (1%), col 1/63 (1%), char 510336 (215463 (151[ line 5/205 (2%), col 1/63 (1%), char 114160772/60 (383/60 (594/60 (6805/60 (816/60 (10%), char 182/9207 (1%) ]7138349552[ line 6/205 (2%), col 10661872/60 (20831973124859 (2231039460 (2169410/205 (4%), col 13/59 (22%), char 429/9207 (4%) ]1565 (20885259 (2255363660 (216124775759 (2273660 (21918785 (20859859 (2291699/1 (100%), char 963/9207 (10[ line 20/205 (9%), col 13/59 (2276[ line 21/205 (1042 (301035/9207 (11%) ] [ line 22/205 (10%), col 1/1 (106[ line 23/205 (11%), col 13/60 (2178459 (22132 [ line 25/205 (12%), col 1/1 (10085[ line 26/205 (12%), col 13/55 (239837360 (21253820 (65314 [ line 29/205 (14%), col 1/1 (10021[ line 30/205 (14%), col 13/61 (21341550 (26955 [ line 32/205 (15%), col 1/1 (100433[ line 33/205 (16%), col 13/60 (214645065723 (5659 [ line 36/205 (17%), col 1/1 (100707[ line 37/205 (18%), col 13/60 (2183858 (22649945 (28948 [ line 40/205 (19%), col 1/1 (100727namethe name of the function.  This is the minor sortfor this listing. The index shows the location ofthe function in the gprof listing. If the index isin parenthesis it shows where it would appear inthe gprof listing if it were to be printed.^LCopyright (C) 2012-2015 Free Software Foundation, Inc.Copying and distribution of this file, with or without modification,are permitted in any medium without royalty provided the copyrightnotice and this notice are preserved.^LCall graph (explanation follows)granularity: each sample hit covers 4 byte(s) for 1.56% of 0.64 secondsindex % time    self  children    called     name<spontaneous>[1]    100.0    0.02    0.62thread_job [1]0.30    0.00 2217560/2217560     mfabs [2][ line 41/205 (20%), col 13/61 (21402801932 (205520410 (21910555 (23631 [ line 46/205 (22%), col 3/3 (1002007[ line 47/205 (22%), col 13/55 (2320 [ line 48/205 (23%), col 1/1 (100632[ line 49/205 (23%), col 13/69 (18765047 (191453138 (342124 [ line 52/205 (25%), col 3/3 (1003939/54 (1641461/1 (1008051[ line 56/205 (27%), col 13/72 (1894 [ line 57/205 (27%), col 1/1 (100355[ line 58/205 (28%), col 13/50 (2667963 (204166090 (2180159 (225470.15    0.00 1108780/1108780     mfloor [3]0.06    0.00  498951/498951mcos [4]0.04    0.00  554390/554390mceil [5]0.02    0.00  110878/110878mlog [6]0.01    0.00  332634/332634msin [7]0.01    0.00  277195/277195mcosh [8]0.01    0.00  221756/221756msinh [9]0.01    0.00  166317/166317mexp [10]0.01    0.00   55439/55439msqrt [11]-----------------------------------------------0.30    0.00 2217560/2217560     thread_job [1][2]     46.9    0.30    0.00 2217560mfabs [2]-----------------------------------------------0.15    0.00 1108780/1108780     thread_job [1][3]     23.4    0.15    0.00 1108780mfloor [3]-----------------------------------------------0.06    0.00  498951/498951thread_job [1][4]9.4    0.06    0.00  498951mcos [4]-----------------------------------------------0.04    0.00  554390/554390thread_job [1][5]6.2    0.04    0.00  554390mceil [5]23060 (21998358 (226541971793086598260 (215912959 (22407060 (21486159 (2254723060 (21998358 (2265419717958763062834799218395129301070460 (21693148 (27122564 (20774355 (2324154648 (2796564 (2034466756 (234087748 (27648864 (205128954 (247680948 (276309164 (207824055 (2374240-----------------------------------------------0.02    0.00  110878/110878thread_job [1][6]3.1    0.02    0.00  110878mlog [6]-----------------------------------------------0.01    0.00  332634/332634thread_job [1][7]1.6    0.01    0.00  332634msin [7]-----------------------------------------------0.01    0.00  277195/277195thread_job [1][8]1.6    0.01    0.00  277195mcosh [8]-----------------------------------------------0.01    0.00  221756/221756thread_job [1][9]1.6    0.01    0.00  221756msinh [9]-----------------------------------------------0.01    0.00  166317/166317thread_job [1][10]     1.6    0.01    0.00  166317mexp [10]-----------------------------------------------0.01    0.00   55439/55439thread_job [1][11]     1.6    0.01    0.00   55439msqrt [11]-----------------------------------------------0.00    0.00   55440/55440task [13][12]     0.0    0.00    0.00   55440get_random [12]348 (27971464 (20845348 (27797255 (2342013964 (2067839048 (273079854 (245768864 (20127748 (274647656 (23085664 (203446448 (2729653555 (2341264 (2017741448 (27293060 (210669359 (22102829517289216834051776491729the function in the gprof listing. If the index isin parenthesis it shows where it would appear inthe gprof listing if it were to be printed.^LCopyright (C) 2012-2015 Free Software Foundation, Inc.Copying and distribution of this file, with or without modification,are permitted in any medium without royalty provided the copyrightnotice and this notice are preserved.^LCall graph (explanation follows)granularity: each sample hit covers 4 byte(s) for 1.56% of 0.64 secondsindex % time    self  children    called     name<spontaneous>[1]    100.0    0.02    0.62thread_job [1]0.30    0.00 2217560/2217560     mfabs [2]0.15    0.00 1108780/1108780     mfloor [3]0.06    0.00  498951/498951mcos [4]3086598260 (215912959 (2240723060 (21998358 (2265419717958763062834799218395129301070460 (21693148 (27122564 (20774355 (2324154648 (2796564 (2034466756 (234087748 (27648864 (205128954 (247680948 (276309164 (207824055 (2374240-----------------------------------------------0.02    0.00  110878/110878thread_job [1][6]3.1    0.02    0.00  110878mlog [6]-----------------------------------------------0.01    0.00  332634/332634thread_job [1][7]1.6    0.01    0.00  332634msin [7]-----------------------------------------------0.01    0.00  277195/277195thread_job [1][8]1.6    0.01    0.00  277195mcosh [8]-----------------------------------------------0.01    0.00  221756/221756thread_job [1][9]1.6    0.01    0.00  221756msinh [9]-----------------------------------------------0.01    0.00  166317/166317thread_job [1][10]     1.6    0.01    0.00  166317mexp [10]-----------------------------------------------0.01    0.00   55439/55439thread_job [1][11]     1.6    0.01    0.00   55439msqrt [11]-----------------------------------------------0.00    0.00   55440/55440task [13][12]     0.0    0.00    0.00   55440get_random [12]348 (27971464 (208455154 (249092648 (276337264 (204011854 (24754764 (201136148 (273963554 (240924064 (208451348 (27797255 (2342013964 (2067839048 (273079854 (245768864 (20127748 (274647656 (23085664 (203446448 (2729653555 (2341264 (2017741448 (27293060 (210669359 (22102829517289216834051776491729the function in the gprof listing. If the index isin parenthesis it shows where it would appear inthe gprof listing if it were to be printed.^LCopyright (C) 2012-2015 Free Software Foundation, Inc.Copying and distribution of this file, with or without modification,are permitted in any medium without royalty provided the copyrightnotice and this notice are preserved.^LCall graph (explanation follows)granularity: each sample hit covers 4 byte(s) for 1.56% of 0.64 secondsindex % time    self  children    called     name<spontaneous>[1]    100.0    0.02    0.62thread_job [1]0.30    0.00 2217560/2217560     mfabs [2]0.15    0.00 1108780/1108780     mfloor [3]0.06    0.00  498951/498951mcos [4]3086598260 (215912959 (22407060 (214865983 (2017850 (26365 [ line 57/205 (27%), col 1/1 (10054[ line 56/205 (27%), col 13/72 (18294 [ line 55/205 (26%), col 1/1 (1008140359/54 (164123/3 (10039[ line 51/205 (24%), col 13/38 (3412067 (1914534939 (180762 [ line 48/205 (23%), col 1/1 (10063[ line 47/205 (22%), col 13/55 (23201 [ line 46/205 (22%), col 3/3 (10007[ line 45/205 (21%), col 13/55 (231963460 (21100302 (20855cumulative a running sum of the number of seconds accounted seconds   for by this function and those listed above it. selfthe number of seconds accounted for by thisseconds    function alone.  This is the major sort for thislisting.callsthe number of times this function was invoked, ifthis function is profiled, else blank. selfthe average number of milliseconds spent in thisms/call    function per call, if this function is profiled,else blank. total     the average number of milliseconds spent in thisms/call    function and its descendents per call, if thisfunction is profiled, else blank.namethe name of the function.  This is the minor sortfor this listing. The index shows the location of21 (21011917408 [ line 40/205 (19%), col 1/1 (10027[ line 39/205 (19%), col 13/45 (286948858 (22437760 (2158 [ line 36/205 (17%), col 1/1 (10070[ line 35/205 (17%), col 13/23 (565964660 (21063445 [ line 32/205 (15%), col 1/1 (10033[ line 31/205 (15%), col 13/50 (263950461 (21344 [ line 29/205 (14%), col 1/1 (10021[ line 28/205 (13%), col 13/20 (6513760 (212536255 (23198 [ line 25/205 (12%), col 1/1 (100852[ line 24/205 (11%), col 13/59 (2238360 (21071 [ line 22/205 (10%), col 1/1 (10065Flat profile:Each sample counts as 0.01 seconds.%   cumulative   selfself     total time   seconds   seconds    calls  ns/call  ns/call  name 46.880.30     0.30  2217560   135.28   135.28  mfabs 23.440.45     0.15  1108780   135.28   135.28  mfloor9.380.51     0.06   498951   120.25   120.25  mcos6.250.55     0.04   554390    72.15    72.15  mceil3.120.57     0.02   110878   180.38   180.38  mlog3.120.59     0.02thread_job1.560.60     0.01   332634    30.06    30.06  msin1.560.61     0.01   277195    36.08    36.08  mcosh1.560.62     0.01   221756    45.09    45.09  msinh1.560.63     0.01   166317    60.13    60.13  mexp1.560.64     0.01    55439   180.38   180.38  msqrt0.000.64     0.00    55440     0.00     0.00  get_random0.000.64     0.001     0.00     0.00  task %the percentage of the total running time of thetimeprogram used by this function.[ line 21/205 (10%), col 13/42 (33 [ line 20/205 (959 (22976/9207 (10%) ] [ line 19/205 (9%), col 1/1 (10063[ line 18/205 (8%), col 59/59 (100%), char 962/9207 (10%) ] [ line 19/205 (9%), col 1/1 (100%), char 963
Modifiednamethe name of the function.  This is the minor sort459 (1%), char 963/9206 [ line 18/204 (8%), col 1/59 (1%), char 904/9206 (9765839859904[ line 19/204 (9%), col 1/59 (1%), char 963/9206 (10Use "fg" to return to nano.

[1]+  Stopped                 sudo nano -c informe.txt
student@2ac:~$ sudo nano -c informe.txt 
File informe.txt is being edited (by root with nano 2.5.3, PID 1888); continue?                                                               Y Yes N No^C Cancel  GNU nano 2.5.3                                    New Buffer                                                                                [ line 1/1 (100%), col 1/1 (100%), char 0/0 (0%) ]^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     ^Y Prev Page   M-\ First Line M-W WhereIs Next^X Exit^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  ^V Next Page   M-/ Last Line  M-] To Bracket [ Unknown Command ][ line 1/1 (100%), col 1/1 (100%), char 0/0 (0%) ]student@2ac:~$ sudonsudo nano -c informe.txt
File informe.txt is being edited (by root with nano 2.5.3, PID 1888); continue?                                                               Y Yes N No^C Cancel [ Reading File ][ Read 204 lines ]  GNU nano 2.5.3                                  File: informe.txt                                                                          Flat profile:Each sample counts as 0.01 seconds.%   cumulative   selfself     total time   seconds   seconds    calls  ns/call  ns/call  name 46.880.30     0.30  2217560   135.28   135.28  mfabs 23.440.45     0.15  1108780   135.28   135.28  mfloor9.380.51     0.06   498951   120.25   120.25  mcos6.250.55     0.04   554390    72.15    72.15  mceil3.120.57     0.02   110878   180.38   180.38  mlog3.120.59     0.02thread_job1.560.60     0.01   332634    30.06    30.06  msin1.560.61     0.01   277195    36.08    36.08  mcosh1.560.62     0.01   221756    45.09    45.09  msinh1.560.63     0.01   166317    60.13    60.13  mexp1.560.64     0.01    55439   180.38   180.38  msqrt0.000.64     0.00    55440     0.00     0.00  get_random0.000.64     0.001     0.00     0.00  task %the percentage of the total running time of thetimeprogram used by this function.cumulative a running sum of the number of seconds accounted seconds   for by this function and those listed above it. selfthe number of seconds accounted for by thisseconds    function alone.  This is the major sort for thislisting.callsthe number of times this function was invoked, ifthis function is profiled, else blank. selfthe average number of milliseconds spent in thisms/call    function per call, if this function is profiled,else blank. total     the average number of milliseconds spent in thisms/call    function and its descendents per call, if thisfunction is profiled, else blank.^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     ^Y Prev Page   M-\ First Line M-W WhereIs Next^X Exit^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  ^V Next Page   M-/ Last Line  M-] To Bracket[ line 2/205 (0%), col 1/1 (100%), char 14/9207 (0%) ] [ line 3/205 (1%), col 1/36 (25463 (151[ line 5/205 (2%), col 1/63 (1%), char 1141student@2ac:~$ ls
2ac-pl4-uo281827  cpu.txt  examen1.tar.gz  gmon.out  informe.txt  program  program2  program3  program.c  results.xls
student@2ac:~$ sud0 mdo mkdri idir Examen - PL - UO281827 41
mkdir: cannot create directory -: File exists
student@2ac:~$ sudo mkdri ir Examen1-PPL4-UO281827
student@2ac:~$ ls
-                 cpu.txt  Examen1-PL4-UO281827  gmon.out     PL4      program2  program.c    UO281827
2ac-pl4-uo281827  Examen1  examen1.tar.gz        informe.txt  program  program3  results.xls
student@2ac:~$ sudo rm -f f - PL4 -UO281827
rm: cannot remove '-': Is a directory
rm: cannot remove 'PL4': Is a directory
rm: cannot remove 'UO281827': Is a directory
student@2ac:~$ suodo rm -d - PL4 UO281827
student@2ac:~$ ls
2ac-pl4-uo281827  Examen1               examen1.tar.gz  informe.txt  program2  program.c
cpu.txt           Examen1-PL4-UO281827  gmon.out        program      program3  results.xls
student@2ac:~$ suod odo rm -d Eaxamen1
student@2ac:~$ ls
2ac-pl4-uo281827  cpu.txt  Examen1-PL4-UO281827  examen1.tar.gz  gmon.out  informe.txt  program  program2  program3  program.c  results.xls
student@2ac:~$ sudo mv cpu.txt exagmon.sudo mv cpu.txt gmon.out informe.txt progrtaam program2 program3 provgram.c resuesults.xls .&//examen1.tar.gz Exaemanmen1-PL4-UO281827/
student@2ac:~$ ls
2ac-pl4-uo281827  Examen1-PL4-UO281827  examen1.tar.gz  results.xls
student@2ac:~$ cd Examen1-PL4-UO281827/
student@2ac:~/Examen1-PL4-UO281827$ ls
cpu.txt  gmon.out  informe.txt  program  program2  program3  program.c
student@2ac:~/Examen1-PL4-UO281827$ sudo naono informe.txt 
[ Reading File ][ Read 204 lines ]  GNU nano 2.5.3                                  File: informe.txt                                                                          Flat profile:Each sample counts as 0.01 seconds.%   cumulative   selfself     total time   seconds   seconds    calls  ns/call  ns/call  name 46.880.30     0.30  2217560   135.28   135.28  mfabs 23.440.45     0.15  1108780   135.28   135.28  mfloor9.380.51     0.06   498951   120.25   120.25  mcos6.250.55     0.04   554390    72.15    72.15  mceil3.120.57     0.02   110878   180.38   180.38  mlog3.120.59     0.02thread_job1.560.60     0.01   332634    30.06    30.06  msin1.560.61     0.01   277195    36.08    36.08  mcosh1.560.62     0.01   221756    45.09    45.09  msinh1.560.63     0.01   166317    60.13    60.13  mexp1.560.64     0.01    55439   180.38   180.38  msqrt0.000.64     0.00    55440     0.00     0.00  get_random0.000.64     0.001     0.00     0.00  task %the percentage of the total running time of thetimeprogram used by this function.cumulative a running sum of the number of seconds accounted seconds   for by this function and those listed above it. selfthe number of seconds accounted for by thisseconds    function alone.  This is the major sort for thislisting.callsthe number of times this function was invoked, ifthis function is profiled, else blank. selfthe average number of milliseconds spent in thisms/call    function per call, if this function is profiled,else blank. total     the average number of milliseconds spent in thisms/call    function and its descendents per call, if thisfunction is profiled, else blank.^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     ^Y Prev Page   M-\ First Line M-W WhereIs Next^X Exit^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  ^V Next Page   M-/ Last Line  M-] To Bracketstudent@2ac:~/Examen1-PL4-UO281827$ sudo nano program.c
[ Reading File ][ Read 284 lines ]  GNU nano 2.5.3                                  File: program.c                                                                            #include <stdio.h>#include <stdlib.h> #include <math.h>#include <pthread.h>#define MAX_NTASKS_NTHREADS 22 // Maximum number of tasks and threads//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write down your DNI without the final letter//////////////////////////////////////////////////////////////////////////////////const unsigned int DNI = 53777253; // Example: const unsigned int DNI = 12345678 const unsigned long NELEMENTS = 55440; // Number of elements to be processed by a task// Structure with the parameters of each threadtypedef struct{double *data; // Array with dataunsigned int minIndex; // Minimum array index to processunsigned int maxIndex; // Maximum array index to process} threadArgs_t;// Data to be proceeeed by the tasks. One pointer per taskdouble *data[MAX_NTASKS_NTHREADS] ;// Thread function argumentsthreadArgs_t threadArgs[MAX_NTASKS_NTHREADS]; int task(unsigned int taskIndex, unsigned int nTaskThreads, pthread_t threadIDs[]);double mcos(double val);double msin(double val);double mcosh(double val);double msinh(double val);double mexp(double val);double mlog(double val);double msqrt(double val);double mfabs(double val);double mfloor(double val);double mceil(double val);^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     ^Y Prev Page   M-\ First Line M-W WhereIs Next^X Exit^R Read File   ^\ Replace     ^U Uncut Text  ^T To Spell    ^_ Go To Line  ^V Next Page   M-/ Last Line  M-] To Bracket// Functions to run on each elementconst unsigned int NFUNCTIONS = 10;double (*funcArray[10])(double) = {mcos, msin, mcosh, msinh, mexp, mlog, msqrt, mfabs, mfloor, mceil}; unsigned long NTIMES[10] = {40, 20, 10, 9, 6, 5, 4, 3, 2, 1};int main(int argc, char* argv[]){struct timespec t1, t2;double time12;// Get program argumentsif (argc != 3){fprintf(stderr, "Usage: %s ntasks nthreads\n", argv[0]);exit(EXIT_FAILURE);}unsigned int nTasks = atoi(argv[1]);unsigned int nThreads = atoi(argv[2]);if ((nTasks <= 0) || (nTasks > MAX_NTASKS_NTHREADS)){fprintf(stderr, "ERROR: task count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if ((nThreads <= 0) || (nThreads > MAX_NTASKS_NTHREADS)){fprintf(stderr, "ERROR: thread count should be between [1, %d]\n", MAX_NTASKS_NTHREADS);exit(EXIT_FAILURE);}if (nTasks > 1 && nThreads != nTasks){fprintf(stderr, "ERROR: thread count should be equal to task count for task count > 1\n");exit(EXIT_FAILURE);             }if (nTasks == 1 && nThreads == 1)printf("Running 1 monolitic task...\n");else if (nTasks == 1 && nThreads > 1)printf("Running 1 muktithreaded task...\n");elseprintf("Running %d monolitic tasks, each on a different thread...\n", nTasks);unsigned int nTaskThreads = nThreads / nTasks; // Number of threads for each taskpthread_t threadIDs[nThreads]; // Thread IDs//////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write here the appropiate instructions to start time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &t1);// Start all the tasksfor (unsigned int taskIndex = 0; taskIndex < nTasks; taskIndex++){// Each task run nTaskThreads threads and saves their IDs into threads arrayif (task(taskIndex, nTaskThreads, threadIDs) < 0){fprintf(stderr, "Error running the task %d", taskIndex);exit(EXIT_FAILURE);}}// Wait for the threads of all the tasks to finishfor (unsigned int threadIndex = 0; threadIndex < nThreads; threadIndex++)pthread_join(threadIDs[threadIndex], NULL);// Free memmoryfor (unsigned taskIndex = 0; taskIndex < nTasks; taskIndex++)if (data[taskIndex] != NULL)free(data[taskIndex]);//////////////////////////////////////////////////////////////////////////////////// Finish measuring time// TODO: Write here the appropiate instructions to finish time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &t2);printf("Execution finished\n");//////////////////////////////////////////////////////////////////////////////////// Show the elapsed time// TODO: Write here the appropiate instructions to calculate the elapsed time//////////////////////////////////////////////////////////////////////////////////time12 = (t2.tv_sec - t1.tv_sec);time12 += (t2.tv_nsec - t1.tv_nsec) / 1e+9;     printf("Elapsed time    : %f s.\n", time12);return 0;}// Return a random number in the interval [min, max]double get_random(unsigned int min, unsigned int max){return min + (max - min) * ((double)rand()/(double)RAND_MAX);}// Function called by every threadvoid *thread_job(void *args){threadArgs_t *threadArgs = (threadArgs_t *)args;double *dta = threadArgs->data;unsigned int minIndex = threadArgs->minIndex;unsigned int maxIndex = threadArgs->maxIndex;unsigned int nTimesIndex = DNI % 10;for (unsigned int funcIndex = 0; funcIndex < NFUNCTIONS; funcIndex++){for (unsigned int i = 0; i < NTIMES[nTimesIndex]; i++)for (unsigned int elementIndex = minIndex; elementIndex < maxIndex; elementIndex++){funcArray[funcIndex](dta[elementIndex]);}nTimesIndex++;if (nTimesIndex == NFUNCTIONS)nTimesIndex = 0;}       return NULL;}// Run task of index taskIndex using nTaskThreads threads. Thread IDs are saved in threadIDsint task(unsigned int taskIndex, unsigned int nTaskThreads, pthread_t threadIDs[]){static unsigned int seed = 0; // Random seed// Get memory for the array of random numbersdata[taskIndex] = (double*)malloc(NELEMENTS * sizeof(double));if (data[taskIndex] == NULL){printf("ERROR in task %d: Cannot allocate memory\n", taskIndex);return -1;}srand(seed++); // Random seed changes with every task// Fill the array with random elementsfor (unsigned int i = 0; i < NELEMENTS; i++){// Pseudo-random numbers in the interval [1.0, 5.0]data[taskIndex][i] = get_random(1, 5);}// Start task threadsunsigned int nThreadPoints = NELEMENTS / nTaskThreads;for (unsigned int threadIndex = 0; threadIndex < nTaskThreads; threadIndex++){if (data[taskIndex] == NULL){printf("ERROR in task %d: Cannot allocate memory\n", taskIndex);return -1;}srand(seed++); // Random seed changes with every task // Fill the array with random elementsfor (unsigned int i = 0; i < NELEMENTS; i++) { // Pseudo-random numbers in the interval [1.0, 5.0] data[taskIndex][i] = get_random(1, 5);}  // Start task threads unsigned int nThreadPoints = NELEMENTS / nTaskThreads;for (unsigned int threadIndex = 0; threadIndex < nTaskThreads; threadIndex++){ threadArgs[threadIndex].data = data[taskIndex]; threadArgs[threadIndex].minIndex = threadIndex * nThreadPoints; threadArgs[threadIndex].maxIndex = threadArgs[threadIndex].minIndex + nThreadPoints - 1; pthread_t firstThreadId = taskIndex * nTaskThreads; // ID for the first task thread if (pthread_create(&(threadIDs[firstThreadId + threadIndex]), NULL, thread_job,  &(threadArgs[threadIndex]))) {fprintf(stderr, "ERROR in pthread_create()"); exit(EXIT_FAILURE); } printf("Running thread %d of task %d; minIndex = %d, maxIndex = %d\n",  taskIndex, threadIndex, threadArgs[threadIndex].minIndex, threadArgs[threadIndex].maxIndex);}return 0;}double mcos(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += cos(val);return a;}double msin(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += sin(val);return a;}double mcosh(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += cosh(val);return a;}double msinh(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += sinh(val);return a;}double mexp(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += exp(val);return a;}double mlog(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += log(val);return a;}double msqrt(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += sqrt(val);return a;}double mfabs(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += fabs(val);return a;}double mfloor(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += floor(val);return a;}double mceil(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += ceil(val);return a;}double a = 0.0;for (int i = 0; i < 50; i++)a += sinh(val);return a;}double mexp(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += exp(val);return a;}double mlog(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += log(val);return a;}return a;}double msin(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += sin(val);return a;}double mcosh(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += cosh(val);return a;}double msinh(double val){threadArgs[threadIndex].maxIndex = threadArgs[threadIndex].minIndex + nThreadPoints - 1;pthread_t firstThreadId = taskIndex * nTaskThreads; // ID for the first task thread if (pthread_create(&(threadIDs[firstThreadId + threadIndex]), NULL, thread_job, &(threadArgs[threadIndex]))){fprintf(stderr, "ERROR in pthread_create()");exit(EXIT_FAILURE);}printf("Running thread %d of task %d; minIndex = %d, maxIndex = %d\n", taskIndex, threadIndex, threadArgs[threadIndex].minIndex, threadArgs[threadIndex].maxIndex);}return 0;}double mcos(double val){double a = 0.0;for (int i = 0; i < 50; i++)a += cos(val);if (data[taskIndex] == NULL){printf("ERROR in task %d: Cannot allocate memory\n", taskIndex);return -1;}srand(seed++); // Random seed changes with every task// Fill the array with random elementsfor (unsigned int i = 0; i < NELEMENTS; i++){// Pseudo-random numbers in the interval [1.0, 5.0]data[taskIndex][i] = get_random(1, 5);}// Start task threadsunsigned int nThreadPoints = NELEMENTS / nTaskThreads;for (unsigned int threadIndex = 0; threadIndex < nTaskThreads; threadIndex++){threadArgs[threadIndex].data = data[taskIndex];threadArgs[threadIndex].minIndex = threadIndex * nThreadPoints;{for (unsigned int i = 0; i < NTIMES[nTimesIndex]; i++)for (unsigned int elementIndex = minIndex; elementIndex < maxIndex; elementIndex++){funcArray[funcIndex](dta[elementIndex]);}nTimesIndex++;if (nTimesIndex == NFUNCTIONS)nTimesIndex = 0;}       return NULL;}// Run task of index taskIndex using nTaskThreads threads. Thread IDs are saved in threadIDsint task(unsigned int taskIndex, unsigned int nTaskThreads, pthread_t threadIDs[]){static unsigned int seed = 0; // Random seed// Get memory for the array of random numbersdata[taskIndex] = (double*)malloc(NELEMENTS * sizeof(double));printf("Elapsed time    : %f s.\n", time12);return 0;}// Return a random number in the interval [min, max]double get_random(unsigned int min, unsigned int max){return min + (max - min) * ((double)rand()/(double)RAND_MAX);}// Function called by every threadvoid *thread_job(void *args){threadArgs_t *threadArgs = (threadArgs_t *)args;double *dta = threadArgs->data;unsigned int minIndex = threadArgs->minIndex;unsigned int maxIndex = threadArgs->maxIndex;unsigned int nTimesIndex = DNI % 10;for (unsigned int funcIndex = 0; funcIndex < NFUNCTIONS; funcIndex++)// Free memmoryfor (unsigned taskIndex = 0; taskIndex < nTasks; taskIndex++)if (data[taskIndex] != NULL)free(data[taskIndex]);//////////////////////////////////////////////////////////////////////////////////// Finish measuring time// TODO: Write here the appropiate instructions to finish time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &t2);printf("Execution finished\n");//////////////////////////////////////////////////////////////////////////////////// Show the elapsed time// TODO: Write here the appropiate instructions to calculate the elapsed time//////////////////////////////////////////////////////////////////////////////////time12 = (t2.tv_sec - t1.tv_sec);time12 += (t2.tv_nsec - t1.tv_nsec) / 1e+9;     //////////////////////////////////////////////////////////////////////////////////// Start measuring time// TODO: Write here the appropiate instructions to start time measurement//////////////////////////////////////////////////////////////////////////////////clock_gettime(CLOCK_REALTIME, &t1);// Start all the tasksfor (unsigned int taskIndex = 0; taskIndex < nTasks; taskIndex++){// Each task run nTaskThreads threads and saves their IDs into threads arrayif (task(taskIndex, nTaskThreads, threadIDs) < 0){fprintf(stderr, "Error running the task %d", taskIndex);exit(EXIT_FAILURE);}}// Wait for the threads of all the tasks to finishfor (unsigned int threadIndex = 0; threadIndex < nThreads; threadIndex++)pthread_join(threadIDs[threadIndex], NULL);student@2ac:~/Examen1-PL4-UO281827$ suro rm do rm rm -f results.xls
rm: cannot remove 'results.xls': No such file or directory
student@2ac:~/Examen1-PL4-UO281827$ ls
cpu.txt  gmon.out  informe.txt  program  program2  program3  program.c
student@2ac:~/Examen1-PL4-UO281827$ cdd ..
student@2ac:~$ ls
2ac-pl4-uo281827  Examen1-PL4-UO281827  examen1.tar.gz  results.xls
student@2ac:~$ sudo rm results.xls
student@2ac:~$ ls
2ac-pl4-uo281827  Examen1-PL4-UO281827  examen1.tar.gz
student@2ac:~$ cd Examen1-PL4-UO281827/
student@2ac:~/Examen1-PL4-UO281827$ ls
cpu.txt  gmon.out  informe.txt  program  program2  program3  program.c
student@2ac:~/Examen1-PL4-UO281827$ suordo mv informe.txt  ./gporof.txt
student@2ac:~/Examen1-PL4-UO281827$ ls
cpu.txt  gmon.out  gprof.txt  program  program2  program3  program.c
student@2ac:~/Examen1-PL4-UO281827$ 